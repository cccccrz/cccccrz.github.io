{"posts":[{"title":"C++查漏补缺(1)","text":"记录学习中未知的知识点 RAIIRAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。它是 C++ 之父 Bjarne Stroustrup 提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。 #define#define 宏不受定义域限制 C++新增的4种类型转换目的：克服C语言强制转换缺点 static_cast&lt;&gt;() 编译器检查 dynamic_cast&lt;&gt;() 运行期检查，根据虚表，没有static_cast高效 const_case&lt;&gt;() 去除 const , volatile 和 __unaligned, 特性 reinterpret_cast 重新诠释表达式类型，用于位的重新解释 浮点数比较允许误差 123// float x;const float EPSINON = 0.00001; // 误差if ((x &lt;= -EPSINON) &amp;&amp; (x &gt;= EPSINON)) RTTI运行时类型识别 typeid dynamic_cast vector释放空间std::vector&lt;&gt;()::swap 构建空间交换，来释放空间 vector(v)首先，通过 拷贝构造函数 创建了一个 匿名对象 ，这个匿名对象拥有v的全部数据，但是，没有空闲的空间 12345std::vector&lt;int&gt; v;v.reserve(100);v.resize(5); // capacity:100std::vector&lt;int&gt;(v).swap(v); //构造匿名对象，交换空间， capacity:5// 执行完，匿名对象析构，原空间释放 priority_queue优先队列定义：priority_queue&lt;Type, Container, Functional&gt; 具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 智能指针(smarter pointer)自定义删除器(deleter)shared_ptr 的传递删除器(deleter)方式比较简单, 只需要在参数中添加具体的删除器函数名, 即可; 注意是单参数函数; unique_ptr 的删除器是函数模板(function template), 所以需要在模板类型传递删除器的类型(即函数指针(function pointer)), 再在参数中添加具体删除器;","link":"/2023/04/04/Cpp-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-1/"},{"title":"Github开源库&amp;工具","text":"记录一些开源工具 工具：robotze/GithubDesktopZhTool: Github Desktop 汉化工具 支持 Windows Mac Linux C++isocpp/CppCoreGuidelines：C++ Core Guides是一套关于C++编码的行之有效的指南、规则和最佳实践 (github.com) Qicosmos/Cosmos： C++11基础库 (github.com) krenx1983/think: 纯C语言跨平台开发框架，支持Linux、AIX、HP-UX、Solaris、FreeBSD、MacOSX、Windows等种操作系统，涵盖进程通讯（共享内存、信号量、锁、共享内存队列等）、网络通讯异步框架（集成了select、poll、epoll、kevent四种技术）。 (github.com) JSONnlohmann/json： JSON for Modern C++ (github.com)","link":"/2023/04/05/Github%E5%BC%80%E6%BA%90%E5%BA%93-%E5%B7%A5%E5%85%B7/"},{"title":"C++查漏补缺(2)","text":"记录一些知识点 mutableconst修饰的成员函数，保护了成员不被修改；使用mutable可以突破const限制，常用于lambda函数 12345678910class A { mutable int a_; int b_;public: void setData(int a) const { a_ = a; // pass // b_ = a; // error }}; const修饰的成员函数相当于修饰了this指针，所以也可以使用类型转换修改 12A* const pA = const_cast&lt;A* const&gt;(this);pA-&gt;b_ = a; // 你得知道自己在干什么！ std::atomicC++原子性和内存模型 (rxsi.github.io) C++内存泄漏及解决方法 - 知乎 (zhihu.com) C++ 中的原子性操作_c++中的原子性_Rain-晴天的博客-CSDN博客 C++11中的std::atomic保证的原子性是什么_c++ atomic如何保证原子性_AlbertS的博客-CSDN博客 linux下C++多线程并发之原子操作与无锁编程 - 知乎 (zhihu.com)对int变量赋值的操作是原子的吗？ - 知乎 (zhihu.com) 面经： 更新了一波字节面经，刷刷看吧 (qq.com) 进度： 字节后台社招面经_牛客网 (nowcoder.com)","link":"/2023/04/17/Cpp-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA-2/"},{"title":"QGC开发环境搭建","text":"源码获取&amp;&amp;模块安装&amp;&amp;问题解决 获取源码：克隆存储库（或您的分支），包括子模块： 1git clone --recursive -j8 https://github.com/mavlink/qgroundcontrol.git 更新子模块（每次提取新源代码时都需要）： 1git submodule update --recursive 个别模块获取失败：libs/cpp/parse/nlohmann_json 1git submodule update --init --recursive 出现 the untracked or modified content in submodules 进入该子模块目录，清理 12git reset --hard HEADgit clean -fxd 或者 1git submodule foreach git reset --hard 参考：git submodules with modified and untracked content - why and how to remove it? - Stack Overflow 启动ubuntu 12sudo usermod -a -G dialout $USERsudo apt-get remove modemmanager Q&amp;A1.qmake error : sdl2 development package not found 1sudo apt install libsdl2-dev 2.Linux 安装GStreamer后编译报错：g_once_init_enter ‘__atomic_load’ must not be a pointer to a ‘volatile’ type 解决方案： 删除错误处的 volatile 声明 相关链接：GCC 11 的构建错误（原子作为易失性和循环构造） ·问题 #9669 ·马夫林克/Q地面控制 ·GitHub","link":"/2023/05/09/QGC%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"QList去重","text":"QSet&lt;T&gt; QList::toSet() const 有需要，还可以转回来 QList&lt;T&gt; QSet::toList() const 如果typename T为自定义对象 123456struct T{ qint64 size; QString data; QString uuid;}; 报错： 12QList&lt;T&gt; list;list.toSet(); // error: C2665: &quot;qHash&quot; balabala 因为自定义对象需要提供全局的operator==()和一个全局的qHash() 补充定义： 12inline bool operator==(const T&amp; left, const T&amp; right) { return left.uuid == right.uuid; }Q_DECL_PURE_FUNCTION inline int qHash(const T&amp; key, uint seed = 0) Q_DECL_NOTHROW { return qHash(key.uuid, seed); } 验证一下： 1list.toSet(); // ok","link":"/2023/04/13/QList%E5%8E%BB%E9%87%8D/"},{"title":"QGC 错误日志","text":"记录QGC二次开发遇到的一些问题 Q&amp;A1.Linux 安装GStreamer后编译报错：g_once_init_enter ‘__atomic_load’ must not be a pointer to a ‘volatile’ type 解决方案： 删除错误处的 volatile 声明 相关链接：GCC 11 的构建错误（原子作为易失性和循环构造） ·问题 #9669 ·马夫林克/Q地面控制 ·GitHub 新版本官方已修复","link":"/2023/06/09/QGC%20%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"},{"title":"QML与C++交互","text":"Data Type Conversion Between QML and C++ 1.变量交互方法一 QQmlContext::setContextProperty直接将cpp中的变量注册进qml 1.声明C++类中使用 Q_PROPERTY 宏声明一个可以从QML访问的属性 m_age 1Q_PROPERTY(QString m_age READ getAge WRITE setAge NOTIFY ageChanged) 2.注册定义一个C++类，使用QQmlContex的setContextProperty()成员函数向QML运行上下文环境注册C++类型 1234#include &lt;QQmlContext&gt;Datas datas; // 自定义对象DatasQQmlContext *qmlctx = engine.rootContext();qmlctx-&gt;setContextProperty(&quot;cpp_datas&quot;,&amp;datas); //注册datas，qml变量名为cpp_datas Q_INVOKABLE 声明函数 3.使用12// qml文件cpp_datas.m_age 方法二qmlRegisterSingletonType 模板函数注册一个单例类供Qml使用 qmlRegisterUncreatableType 注册一个QML不可实例化的类型 搭配使用，可以在cpp中管理对象，在QML中使用单例对象操作交互 1.声明自定义全局单例类MyQmlGlocalControl，管理QML使用的对象 12345678910111213141516class MyQmlGlocalControl : public QObject{ Q_OBJECTpublic: explicit MyQmlGlocalControl(QObject *parent = nullptr) { // cpp中实例化对象 _testManager = new TestManager; } Q_PROPERTY(TestManager* testManager READ testManager CONSTANT) TestManager* testManager() { return _testManager; }private: TestManager* _testManager;}; 需要与QML 交互的对象 TestManager 12345678910111213141516class TestManager : public QObject{ Q_OBJECTpublic: explicit TestManager(QObject *parent = nullptr); Q_PROPERTY(int age READ age NOTIFY ageChanged) int age() { return _age; }signals: void ageChanged();private: int _age = 5;}; 2.注册12345static QObject* myQmlGlobalSingletonFactory(QQmlEngine*, QJSEngine*){ MyQmlGlocalControl* qmlGlobal = new MyQmlGlocalControl; return qmlGlobal;} 123// 模块名MyQml, QML中使用全局对象名MyQmlqmlRegisterUncreatableType&lt;TestManager&gt;(&quot;MyQml&quot;, 1, 0, &quot;TestManager&quot;, &quot;Reference only&quot;);qmlRegisterSingletonType&lt;MyQmlGlocalControl&gt;(&quot;MyQml&quot;, 1, 0, &quot;MyQml&quot;, myQmlGlobalSingletonFactory); 3.使用12345import MyQml 1.0{ property var _testManager: MyQml.testManager // MyQmlGlocalControl::testManager() property int _age: MyQml.testManager.age} 2.信号交互在变量交互的基础上，使用Connections建立cpp/QML信号与QML槽的连接 1234567891011Connections { target: _testManager // Qt Version &gt; 5.15 function onAgeChanged() { console.log(&quot;age changed :&quot;, _age) } // Qt Version &lt; onAgeChanged: { ... }}","link":"/2023/06/01/QML%E4%B8%8EC++%E4%BA%A4%E4%BA%92/"},{"title":"QGC架构设计","text":"设计文档 通信流 Communication Flow描述载具在自动连接期间进行的高级通信流程。 LinkManager总是有一个UDP端口打开等待车辆心跳 LinkManager检测到一个新的已知设备类型(Pixhawk, SiK Radio, PX4 Flow)，使UDP连接到计算机 LinkManager在计算机和设备之间创建一个新的SerialLink 来自链路的传入字节被发送到MAVLinkProtocol MAVLinkProtocol将字节转换为MAVLink消息 如果消息是HEARTBEAT，则通知MultiVehicleManager(多机管理类) MultiVehicleManager收到HEARTBEAT的通知，并根据HEARTBEAT消息中的信息创建一个新的vehicle 车辆对象 vehicle对象实例化与车辆匹配的插件 与vehicle对象相关联的ParameterLoader发送一个 PARAM_REQUEST_LIST到连接的设备，以使用参数协议加载参数( to load parameters using the parameter protocol) 参数加载完成后，与vehicle对象相关联的MissionManager使用任务协议(mission protocol)从连接的设备请求任务项(mission items) 当参数加载完成后，VehicleComponents对象将在Setup视图中显示其UI 插件架构设计 Plugin Architecture虽然MAVLink规范定义了与载具通信的标准通信协议。该规范的许多方面需要固件开发人员来解释。正因为如此，在许多情况下，为了完成相同的任务，与运行一个固件的车辆的通信与运行不同固件的车辆的通信略有不同。此外，每个固件可以实现MAVLink命令集的不同子集。 另一个主要问题是MAVLink规范不包括载具配置或通用参数集。 因此，所有与车辆设置相关的代码最终都是固件特定的。此外，任何必须引用特定参数的代码也是特定于固件的。 鉴于固件实现之间的所有这些差异，创建单个地面站应用程序可能非常棘手，可以支持每个应用程序而不会使代码库降级为基于车辆使用的固件在任何地方遍布的大量if / then / else语句。 QGC使用插件架构将固件特定代码与所有固件通用代码隔离开来。有两个主要的插件可以完成这个 FirmwarePlugin和AutoPilotPlugin 。 自定义构建也使用此插件架构，以允许超出标准QGC所能提供的范围的进一步自定义。 FirmwarePlugin这是用来创建一个标准接口到Mavlink的部分，这通常是不标准化的。 AutoPilotPlugin这用于为车辆设置提供用户界面。 QGCCorePlugin这用于通过标准接口公开与车辆无关的QGC应用程序本身的特性。然后由自定义构建使用它来调整QGC特性集以满足其需求。 类层次结构（上层）(LinkManager)链接管理器类，(LinkInterface)链接接口类QGC中的“链接”是QGC与载具间的一种特定类型的通信管道，例如串行端口或基于WiFi的UDP端口。 LinkInterface为所有链接的基类。 每个链接都在它自己的线程上运行，并将字节发送到MAVLinkProtocol。 LinkManager类所生成对象管理系统中的所有打开链接。 LinkManager还通过串行和UDP链接管理自动连接 MAVLink协议类系统中有一个MAVLink协议对象。 它的功能是从链接获取传入的字节并将它们转换为MAVLink消息。 MAVLink HEARTBEAT消息被分发到MultiVehicleManager(多机管理类)。 所有MAVLink消息都将分发到与链接相对应的载具。 (MultiVehicleManager)多机管理类系统中有一个MultiVehicleManager多机管理类生成的对象, 当它接收到一个新的心跳包(通过心跳包里面的系统ID识别)，它会自动生成一个载具对象，来表示一个新的载具加入到系统。MultiVehicleManager还可以保持对系统中所有载具的跟踪，对于激活状态的载具可以自由切换，而对于正在被移除的也能够正确处理。 (Vehicle)载具类Vehicle类所生成的对象是QGC代码与物理载具通信的主要接口。 注意：还有一个与每个Vehicle相关联的UAS对象，这是一个已弃用的类，并且正逐渐被逐步淘汰，所有功能都转移到Vehicle类。 这里不应该添加新代码。 (FirmwarePlugin)固件插件类，( FirmwarePluginManager)固件插件管理器类FirmwarePlugin类为固件插件的基类。 固件插件包含固件特定代码，因此Vehicle对象相对于它是识别的，支持UI的单个标准接口。 FirmwarePluginManager是一个工厂类，它根据Vehicle类的成员MAV_AUTOPILOT / MAV_TYPE组合创建FirmwarePlugin类的实例。 用户界面设计QGC中UI设计的主要模式是用QML编写的UI页面，多次与用C ++编写的自定义“Controller”进行通信。 这种设计模式有点沿用MVC设计模式，但也有显著不同之处。 QML代码通过以下机制绑定到与系统关联的信息： 自定义控制器 全局QGroundControl对象，提供对活动Vehicle等内容的访问 FactSystem提供对参数的访问，在某些情况下提供自定义事实。 注意：由于QGC中使用的QML的复杂性以及它依赖于与C ++对象的通信来驱动ui，因此无法使用Qt提供的QML Designer来编辑QML。 多设备设计模式QGroundControl设计用于从桌面到笔记本电脑，平板电脑和使用鼠标和触摸的小型手机屏幕等多种设备类型。 以下是QGC如何做到以及背后原理的描述。 目标设备从触摸的角度和屏幕尺寸的角度来看，QGC UI设计的优先目标是平板电脑（比如三星Galaxy）。 由于此决定，其他设备类型和大小可能会看到一些视觉和/或可用性的错误。 基于优先级的决策时的当前顺序是平板电脑，笔记本电脑，台式机，电话（任何小屏幕）。 使用的开发工具Qt布局控件QGC没有针对不同屏幕尺寸和/或形状因子的不同编码的UI。 通常，它使用QML Layout功能来重排一组QML UI代码以适应不同的外形。 在某些情况下，它提供了较小的屏幕尺寸细节，使事情适合。 但这是一个简单的可见性模式。 FactSystem（事实系统）QGC内部是一个系统，用于管理系统中的所有单个数据。 这个数据模型是连接到控件的。 严重依赖可重用控件QGC UI是从一组可重用的控件和UI元素开发而来的。 这样，现在可以在整个UI中使用添加到可重用控件的任何新功能。 这些可重用的控件还连接到FactSystem Facts，然后FactSystem Facts自动提供适当的UI。 字体和调色板QGC有一套标准的字体和调色板，应该由所有用户界面使用。 12import QGroundControl.Palette 1.0import QGroundControl.ScreenTools 1.0 QGCPalette(QGC调色板)此项目显示QGC调色板。 这个调色板有两种变体：浅色和深色。 较浅的调色板适合户外使用，黑色调色板适用于室内。 通常，您不应该直接为UI指定颜色，您应该使用调色板中的颜色。 如果不遵循此规则，则您创建的用户界面将无法通过浅色/深色样式更改。 QGCMapPalette(QGC地图调色板)地图调色板用于绘制地图的颜色。 由于不同的地图样式，特别是卫星和街道，您需要有不同的颜色来清晰地绘制它们。 卫星地图需要更浅的颜色，而街道地图需要更深的颜色。 QGCMapPalette项目为此提供了一组颜色，以及在地图上切换浅色和深色的功能。 ScreenTools (屏幕工具)ScreenTools项提供可用于指定字体大小的值。 它还提供有关屏幕大小以及QGC是否在移动设备上运行的信息。 用户界面控件QGC提供了一组用于构建用户界面的基本控件。 一般来说，它们往往是Qt支持的基本QML控件上方的薄层，Qt控件支持QGC调色板。 1import QGroundControl.Controls 1.0 Qt控件以下控件是标准Qt QML控件的QGC变体。 除了使用QGC调色板绘制。 它还们提供与相应Qt控件相同的功能， QGCButton QGCCheckBox QGCColoredImage QGCComboBox QGCFlickable QGCLabel QGCMovableItem QGCRadioButton QGCSlider QGCTextField QGC 控件这些自定义控件是QGC独有的，用于创建标准UI元素。 DropButton - RoundButton，单击时会删除一组选项。 示例是平面视图中的同步按钮。 ExclusiveGroupItem - 用于支持QML ExclusiveGroup 概念的自定义控制的基础项目。 QGCView - 系统中所有顶级视图的基本控件。 提供对FactPanels的支持并显示QGCViewDialogs和QGCViewMessages。 QGCViewDialog - 从QGC视图右侧弹出的对话框。 您可以指定对话框的接受/拒绝按钮以及对话框内容。 使用示例是当您单击某个参数并显示值编辑器对话框时。 QGCViewMessage - QGCViewDialog的简化版本，允许您指定按钮和简单的文本消息。 QGCViewPanel - QGCView内部的主要视图内容。 RoundButton - 一个圆形按钮控件，它使用图像作为其内部内容。 SetupPage - 所有安装载具组件页面的基本控件。 提供标题，说明和组件页面内容区域。 Fact System(事实系统)Fact System(事实系统)提供一组标准化和简化QGC用户界面创建的功能。 Fact事实代表系统中的单个值。 FactMetaData与每个事实有FactMetaData相关联 它提供有关事实的详细信息，以便驱动自动用户界面生成和验证。 事实控制事实控件是一个QML用户界面控件，它连接到Fact和它的FactMetaData，为用户提供控件以修改/显示与Fact相关的值。 FactGroup（事实小组）FactGroup是一组Facts。它用于组织事实和管理用户定义的Fact。 自定义构建支持用户定义的Fact可以通过在自定义固件插件类中覆盖FirmwarePlugin的factGroups函数来添加。这些函数返回事实组映射的名称，该名称用于标识添加的事实组。可以通过扩展FactGroup类来添加自定义事实组。通过提供包含必要信息的json文件，可以使用适当的FactGroup构造函数来定义FactMetaData。通过重写FirmwarePlugin类的adjustMetaData，也可以更改现有事实的元数据。与车辆相关的Fact(包括属于车辆固件插件的factGroups函数返回的事实组的事实)可以使用getFact(“factName”)或getFact(“factGroupName.factName”) 获取更多信息，请参阅FirmwarePlugin.h中的注释。 顶级视图本节包含有关顶级视图代码的主题：设置，设置，计划和飞行。 Settings View 顶级QML代码是AppSettings.qml 每个按钮都会加载一个单独的QML页面 Setup View 在SetupView.qml中实现的顶级QML代码 固定的按钮/页面集：摘要，固件 按钮/页面的剩余部分来自AutoPilot Plugin Vehicle Component列表 Plan View 最高级别的 QML 代码是 PlanView.qml 主视图UI是FlightMap控件 QML与MissionController（C ++）通信，后者为视图提供任务项数据和方法 用于任务项目编辑的动态UI任务指令树QGC 创建用户界面，用于从 json 元数据的层次结构中动态编辑特定任务项命令。 此层次结构称为任务命令树。 这样，在添加新命令时，只能创建 json 元数据。 为什么是一颗树？需要该树以不同的方式处理不同固件和／或不同的车辆类型，以支持不同的命令。 最简单的例子是 mavlink 规范可能包含了并非所有固件都支持的命令参数。 或着命令参数仅对某些车辆类型有效。 此外，在某些情况下，GCS 可能会决定将某些命令参数在视图中对最终用户进行隐藏，因为它们过于复杂或导致可用性问题。 该树是MissionCommandTree类： MissionCommandTree.cc, MissionCommandTree.h 树根目录树的根目录是与 mavlink 规范完全匹配的json元数据。 您可以在这里看到MAV_CMD_NAV_WAYPOINT根目录json的示例： 12345678910111213141516171819202122232425262728293031323334{ &quot;id&quot;: 16, &quot;rawName&quot;: &quot;MAV_CMD_NAV_WAYPOINT&quot;, &quot;friendlyName&quot;: &quot;Waypoint&quot;, &quot;description&quot;: &quot;Travel to a position in 3D space.&quot;, &quot;specifiesCoordinate&quot;: true, &quot;friendlyEdit&quot;: true, &quot;category&quot;: &quot;Basic&quot;, &quot;param1&quot;: { &quot;label&quot;: &quot;Hold&quot;, &quot;units&quot;: &quot;secs&quot;, &quot;default&quot;: 0, &quot;decimalPlaces&quot;: 0 }, &quot;param2&quot;: { &quot;label&quot;: &quot;Acceptance&quot;, &quot;units&quot;: &quot;m&quot;, &quot;default&quot;: 3, &quot;decimalPlaces&quot;: 2 }, &quot;param3&quot;: { &quot;label&quot;: &quot;PassThru&quot;, &quot;units&quot;: &quot;m&quot;, &quot;default&quot;: 0, &quot;decimalPlaces&quot;: 2 }, &quot;param4&quot;: { &quot;label&quot;: &quot;Yaw&quot;, &quot;units&quot;: &quot;deg&quot;, &quot;nanUnchanged&quot;: true, &quot;default&quot;: null, &quot;decimalPlaces&quot;: 2 }}, 注意：在现实中，基于此的信息应由 mavlink 本身提供，而不需要成为 GCS 的一部分。 叶节点然后，叶节点提供元数据，这些元数据可以覆盖命令的值和/或从显示给用户的参数中删除参数。 完整的树层次结构是这样的： 根－通用Mavlink 特定的车辆类型－特定于车辆的通用规范 特定的硬件类型－每个固件类型有一个可选的叶节点（PX4/ArduPilot） 特定的车辆类型－每个车辆类型有一个可选的叶节点（FW/MR/VTOL/Rover/Sub） 注意：实际上，此替代功能应该是mavlink规格的一部分，并且应该可以从车辆中查询。 从完整树中构建实例树由于 json 元数据提供了所有固件／车辆类型组合的信息，因此必须根据用于创建计划的固件和车辆类型来构建要使用的实际树。 这是通过一个进程调用“collapsing”的完整树到一个固件／车辆的特定树来完成的 (code)。 步骤如下： 在实例树种添加根 将特定的车辆类型重写实例树 Apply the firmware type specific overrides to the instance tree 将特定的硬件／车辆类型重写实例树 然后，生成的任务命令树将为平面项目编辑器构建UI。 实际上，它不仅用于此，还有许多其他地方可以帮助您了解有关特定命令 id 的更多信息。 层次结构示例 MAV_CMD_NAV_WAYPOINT让我们来看看MAV_CMD_NAV_WAYPOINT的示例层次结构。 根信息如上图所示。 根－车辆类型的特定叶节点层次结构的下一个层级是通用的 mavlink，但只针对特定的车辆。 这里的Json文件：MR, FW, ROVER, Sub, VTOL。 这个是重写（固定翼） 12345{ &quot;id&quot;: 16, &quot;comment&quot;: &quot;MAV_CMD_NAV_WAYPOINT&quot;, &quot;paramRemove&quot;: &quot;4&quot;}, 这样做是删除参数4的编辑 UI，固定翼没有使用航向（Yaw）参数。 由于这是根的叶节点，因此无论固件类型如何，这都适用于所有固定翼车辆。 根－硬件类型的特定叶节点层次结构的下一层级是特定于固件类型但适用于所有车辆类型的替代。 再次让我们看看航点（Waypoint）覆盖： ArduPilot： 12345{ &quot;id&quot;: 16, &quot;comment&quot;: &quot;MAV_CMD_NAV_WAYPOINT&quot;, &quot;paramRemove&quot;: &quot;2&quot;}, PX4： 12345{ &quot;id&quot;: 16, &quot;comment&quot;: &quot;MAV_CMD_NAV_WAYPOINT&quot;, &quot;paramRemove&quot;: &quot;2,3&quot;}, 您可以看到，对于两个固件参数参数2，即接受半径，从编辑 ui 中删除。 这是QGC的特性决定。 与指定值相比，使用固件通用接受半径会更加安全和容易。 因此，我们决定对用户隐藏它。 您还可以看到，对于 PX4 param3/PassThru，由于 PX 不支持它，因此已被删除。 根－特定于固件的类型－特定于车辆类型的叶子节点层次结构的最后一个级别既针对固件又针对车辆类型。 ArduPilot/MR: 12345{ &quot;id&quot;: 16, &quot;comment&quot;: &quot;MAV_CMD_NAV_WAYPOINT&quot;, &quot;paramRemove&quot;: &quot;2,3,4&quot;}, 在这里你可以看到，ArduPilot的多电机车辆参数2/3/4 Acceptance/PassThru/Yaw 已被移除。 例如，航向（Yaw）是因为不支持所以被移除。 由于此代码的工作原理的怪癖，您需要从较低级别重复重写。 任务命令 UI 信息两个类定义与命令相关联的元数据： MissionCommandUIInfo－整个命令的元数据 MissionCmdParamInfo－命令中参数的元数据 源中注释了支持 json 键的完整详细信息。 MissionCommandUIInfo： 1234567891011121314151617181920212223/// 与任务命令关联的 UI 信息 （MAV_CMD）//////MissionCommandUIInfo用于自动为MAV_CMD生成编辑ui。 此对象还支持仅具有一组命/// 令的部分信息的概念。 这用于创建基本命令信息的替代。 对于覆盖，只需从基本命/// 令 ui 信息中指定要修改的键即可。 若要重写 ui 参数信息，必须指定整个MissionParamInfo对象。////// MissionCommandUIInfo对象的json格式为：////// 键值 类型 默认值 描述/// id int reauired MAV_CMD id/// comment string 用于添加评论/// rawName string required MAV_CMD 枚举名称，仅应设置基础树信息/// friendlyName string rawName 命令的简单描述/// description string 命令的详细描述/// specifiesCoordinate bool false true: 命令指定一个纬／经／高坐标/// specifiesAltitudeOnly bool false true: 命令仅指定高度（非坐标）/// standaloneCoordinate bool false true: 车辆无法通过与命令关联的坐标（例如：ROI）/// isLandCommand bool false true: 命令指定着陆指令 (LAND, VTOL_LAND, ...)/// friendlyEdit bool false true: 命令支持友好的编辑对话框，false：Command仅支持“显示所有值”样式的编辑/// category string Advanced 该命令所属的类别/// paramRemove string 由替代使用以删除参数，例如：“ 1,3”将删除替代上的参数1和3/// param[1-7] object MissionCommandParamInfo 对象/// MissionCmdParamInfo： 1234567891011121314/// 与任务命令 （MAV_CMD） 参数关联的 UI 信息////// MissionCommandParamInfo 用于自动为与 MAV_CMD 关联的参数生成编辑ui。////// MissionCmdParamInfo 对象的 Json 文件格式为：/// /// 键值 类型 默认值 描述/// label string required 文本字段标签/// units string 值的单位，应使用 FactMetaData Units 字符串以获得自动转换/// default double 0.0/NaN 默认参数值。 如果未指定默认值且 nanunchange==true，默认值为NaN。/// decimalPlaces int 7 显示值得小数位数/// enumStrings string 要在组合框中显示以供选择的字符串/// enumValues string 与每个枚举字符串关联的值/// nanUnchanged bool false True: 值可以设置为NaN表示信号不变 Fly View 顶级QML代码在FlightDisplayView.qml中 QML代码与MissionController（C ++）通信以进行任务显示 仪器小部件与活动的Vehicle对象通信 两个主要的内部view是： FlightDisplayViewMap FlightDisplayViewVideo 文件格式本节包含有关QGroundControl使用/支持的文件格式的主题。 开发者工具QGroundControl主要为自动驾驶开发人员提供了许多工具。 这些简化了常见的开发人员任务，包括设置模拟连接以进行测试，以及通过MAVLink访问系统Shell。 注意:在调试模式下构建源以启用这些工具。 工具包括： Mock Link 模拟链接（仅限每日构建） - 创建和停止多个模拟载具链接。 Replay Flight Data 重播飞行数据 - 重播遥测日志（用户指南）。 MAVLink Inspector - 显示收到的MAVLink消息/值。 MAVLink Analyzer - 绘制MAVLink消息/值的趋势图。 Custom Command Widget 自定义命令小组件 - 在运行时加载自定义/测试QML UI。 Onboard Files 板载文件 - 导航车辆文件系统和上载/下载文件。 HIL Config Widget - HIL模拟器的设置. MAVLink Console（仅限PX4） - 连接到PX4 nsh shell并发送命令。 模拟链接Mock Link允许您在QGroundControl调试版本中创建和停止指向多个模拟（模拟）载具的链接。 模拟不支持飞行，但允许轻松测试： 任务上传/下载 查看和更改参数 测试大多数设置页面 多个载具用户界面 对于任务上载/下载的单元测试错误情况尤其有用。 使用Mock Link为了使用Mock Link： 1.通过构建源来创建调试版本。 通过选择顶部工具栏中的“应用程序设置”图标，然后选择侧栏中的“模拟链接”来访问“模拟链接”： 可以单击面板中的按钮以创建相关类型的车辆链接。 每次单击按钮时，都会创建一个新连接。 当存在多个连接时，将显示多车辆UI。 单击停止一个模拟链接以停止当前活动的车辆。 然后使用模拟链接或多或少与使用任何其他载具相同，只是模拟不允许飞行。 命令行选项您可以使用命令行选项启动QGroundControl。 这些用于启用日志记录，运行单元测试以及模拟不同的主机环境以进行测试。 使用选项启动QGroundControl您需要打开命令提示符或终端，将目录更改为存储qgroundcontrol.exe的位置，然后运行它。 每个平台如下所示（使用–logging：full选项）： Windows命令提示符： 12cd &quot;\\Program Files (x86)\\qgroundcontrol&quot;qgroundcontrol --logging:full OSX终端应用程序（应用程序/实用程序）： 12cd /Applications/qgroundcontrol.app/Contents/MacOS/./qgroundcontrol --logging:full Linux终端： 1./qgroundcontrol-start.sh --logging:full 选项下表列出了选项/命令行参数。 Option Description --clear-settings 清除应用程序设置(将QGroundControl恢复到默认设置)。 --logging:full 打开完整日志记录。参见 Console Logging. --logging:full,LinkManagerVerboseLog,ParameterLoaderLog 打开完整日志记录并关闭以下以逗号分隔的日志记录选项。 --logging:LinkManagerLog,ParameterLoaderLog 打开指定的以逗号分隔的日志记录选项 --unittest:name (Debug builds only)运行指定的单元测试。去掉“:name”以运行所有测试。 --unittest-stress:name (Debug builds only)连续运行指定的单元测试20次。去掉:运行所有测试的名称。 --fake-mobile 模拟在移动设备上运行。 --test-high-dpi 模拟在高DPI设备上运行 Notes: 单元测试自动包含在调试版本中（作为QGroundControl的一部分）。 QGroundControl在单元测试的控制下运行（它不能正常启动）。 自定义构建自定义构建允许第三方创建自己的QGC版本，使其能够轻松跟上常规QGC中所做的更改。QGC内置了一个架构，允许自定义构建修改并添加到常规QGC的功能集中。 定制构建的一些可能性 为您的构建打造完全品牌化 定义单个外部测试版堆栈以避免携带不必要的代码 实现您自己的、自动驾驶仪和固件插件覆盖 实现您自己的相机管理器和插件覆盖 实现您自己的QtQuick接口模块 实现您自己的工具栏、工具栏指示器和 UI 导航 实现您自己的飞行视图叠加层（以及如何隐藏QGC中的元素，例如飞行小部件） 实现您自己的自定义QtQuick相机控制 实施您自己的自定义飞行前检查清单 为上述所有内容定义您自己的资源 QGC为任何支持mavlink的车辆提供通用支持，并为PX4 Pro和ArduPilot提供固件特定支持的缺点之一是用户界面的复杂性。由于QGC事先不知道有关您的车辆的任何信息，因此需要UI位，如果您驾驶的车辆仅使用PX4 Pro固件并且是多旋翼车辆，则可能会妨碍您。如果这是已知的事情，那么可以在不同的地方简化UI。此外，QGC既针对从头开始构建自己车辆的DIY用户，也针对现成车辆的商业用户。从头开始设置 DIY 无人机需要各种功能，而这些功能对于现成车辆的用户来说是不需要的。因此，对于现成的车辆用户来说，所有 DIY 特定的东西都只是他们需要查看的额外噪音。创建自定义构建允许您为车辆指定确切的详细信息并隐藏不相关的内容，从而为您的用户创建比常规通用 QGC 更简单的用户体验。 QGC 中有一个插件架构，允许这种自定义构建创建。它们可以在QGCCorePlugin.h，FirmwarePlugin.h和AutoPilotPlugin.h相关类中找到。要创建自定义构建，您需要创建标准插件的子类，覆盖适合您使用的方法集。 还有一种机制允许您覆盖资源，以便您可以更改 QGC 中较小的可视元素。 QGC内部还有“高级模式”的概念。而标准 QGC 构建始终在高级模式下运行。自定义构建始终以常规/非高级模式启动。构建中有一种更简单的机制可以打开高级模式，即相当快地连续单击 5 次飞行视图按钮。如果在自定义版本中执行此操作，则会警告您进入高级模式。这里的概念是隐藏普通用户不应该在高级模式后面访问的内容。例如，商用车将不需要访问大多数面向DIY设置的设置页面。因此，自定义构建可以隐藏这一点。自定义示例代码演示如何执行此操作。 如果您想了解可能性，第一步是通读那些记录可能性的文件。接下来查看‘ custom-example ‘源代码，包括README 自定义构建的初始存储库设置在QGC和QGC的自定义构建版本上工作的建议机制是有两个单独的存储库。第一个存储库是你的主 QGC 分叉。第二个存储库是自定义生成存储库。 主要QGC存储库此存储库用于处理对主线 QGC 的更改。在创建自己的自定义构建时，发现您可能需要对自定义构建进行调整/添加以实现所需的内容的情况并不少见。通过与 QGC 开发人员直接讨论这些需要的更改并提交拉取以使自定义构建架构更好，您可以使 QGC 对每个人来说更强大，并回馈社区。 创建此存储库的最佳方法是将常规 QGC 存储库分叉到您自己的 GitHub 帐户。 自定义构建存储库这是您将进行主要自定义构建开发的地方。此处的所有更改都应在自定义目录中，而不是渗入常规的QGC代码库。 由于只能分叉一次存储库，因此创建此存储库的方法是在 GitHub 帐户中“创建新存储库”。不要向其添加任何其他文件，如 gitignore、readme 等。创建后，您可以选择设置存储库。现在您可以选择“从另一个存储库导入代码”。只需使用“导入代码”按钮导入常规 QGC 存储库即可。 自定义构建插件为自定义构建自定义 QGC 的机制是通过现有的 和体系结构。通过在自定义构建中创建这些插件的子类，您可以更改 QGC 的行为以满足您的需求，而无需修改上游代码。FirmwarePlugin``AutoPilotPlugin``QGCCorePlugin QGCCorePlugin这允许您修改 QGC 中与车辆没有直接关系但与 QGC 应用程序本身相关的部分。这包括应用程序设置、调色板、品牌等内容。 资源覆盖QGC 源代码术语中的“资源”是指在 qgroundcontrol.qrc 和 qgcresources.qrc 文件中找到的任何内容。通过覆盖资源，您可以将其替换为您自己的版本。这可以像单个图标一样简单，也可以像替换 qml UI 代码的整个车辆设置页面一样复杂。 请注意，使用资源覆盖并不像插件架构那样将您与上游 QGC 更改隔离开来。从某种意义上说，您直接修改了主代码使用的上游 QGC 资源。 排除文件覆盖资源的第一步是将其从上游构建的标准部分中“排除”。这意味着您将在自己的自定义生成资源文件中提供该资源。有两个文件可以实现这一点：qgroundcontrol.exclusion和qgcresources.exclusion。它们直接与 *.qrc 对应项对应。要排除资源，请将资源行从 .qrc 文件复制到相应的 .exclusion 文件中。 排除资源的自定义版本必须在自定义生成资源文件中包含重写资源的自定义版本。资源别名必须与上游别名完全匹配。资源的名称和实际位置可以位于自定义目录结构中的任何位置。 生成标准 QGC 资源文件的新修改版本这是使用python脚本updateqrc.py 完成的。它将读取上游 qgroundcontrol.qrc 和qgcresources.qrc和相应的 exclusion files，并在自定义目录中输出这些文件的新版本。这些新版本将不包含指定要排除的资源。定制构建的构建系统使用这些生成的文件(如果存在的话)来代替上游版本进行构建。这些文件的生成版本应该添加到您的repo中。此外，每当您在自定义repo中更新QGC的上游部分时，您必须重新运行python updateqrc.py以生成新版本的文件，因为上游资源可能已经更改。 自定义构建示例可以在存储库自定义构建示例中查看自定义生成 qgcresource 覆盖的示例： qgcresources.qrc custom.qrc 定制以下主题说明如何自定义 UI 的各种视图和其他部分。 首次运行提示 工具栏自定义 飞视图定制 首次运行提示当QGC第一次启动时，它会提示用户指定一些初始设置。在撰写本文档时，它们是: 单位设置-用户希望使用什么单位来显示。 离线车辆设置-未连接车辆时创建计划的车辆信息。 自定义构建体系结构包括用于自定义构建的机制，以覆盖这些提示的显示和/或创建您自己的首次运行提示。 首次运行提示对话框每个首次运行提示符都是一个简单的对话框，可以向用户显示ui。特定的对话框是否已经显示给用户存储在一个设置中。下面是上游第一次运行提示对话框的代码: Units Settings Offline Vehicle Settings 标准的首次运行提示对话框每个对话框都有一个唯一的ID。当该对话框显示给用户时，该ID被注册为已经显示过，因此它只发生一次(除非您清除设置)。包含在上游QGC中的首次运行提示符集被认为是“标准”集。QGC从 QGCCorePlugin::first strunpromptstdids 调用中获取要显示的标准提示列表。 1234/// Returns the standard list of first run prompt ids for possible display. Actual display is based on the/// current AppSettings::firstRunPromptIds value. The order of this list also determines the order the prompts/// will be displayed in.virtual QList&lt;int&gt; firstRunPromptStdIds(void); 如果想隐藏其中一些，可以在自定义构建中重写此方法。 自定义首次运行提示对话框自定义构建可以根据需要创建自己的一组额外的首次运行提示，通过使用以下QGCCorePlugin方法重写: 123456/// Returns the custom build list of first run prompt ids for possible display. Actual display is based on the/// current AppSettings::firstRunPromptIds value. The order of this list also determines the order the prompts/// will be displayed in.virtual QList&lt;int&gt; firstRunPromptCustomIds(void);/// Returns the resource which contains the specified first run prompt for displayQ_INVOKABLE virtual QString firstRunPromptResource(int id); 您的QGCCorePlugin应该覆盖这两个方法，并为新的首次运行提示符的id提供静态常量。看看标准集是如何实现的，并采用相同的方法。 显示顺序显示给用户的第一次运行提示的集合是按照 QGCCorePlugin::first strunpromptstdids 和 QGCCorePlugin::first strunpromptcustomids 返回的顺序，在自定义提示之前显示标准提示。只显示以前没有显示给用户的提示。 始终打开提示通过在提示ui实现中设置 markAsShownOnClose: false 属性，你可以创建一个每次QGC启动时都会显示的提示符。这可以用于向用户显示使用提示之类的事情。如果您这样做，最好确保最后显示它。 定制工具栏可以通过多种方式定制工具栏，以满足您的定制构建需求。工具栏内部由从左到右的几个部分组成: View Switching Indicators App Indicators Vehicle Indicators Vehicle Mode Indicators Connection Management Branding 根据当前显示的视图，Indicators “指标”部分有所不同: Fly View - 显示所有指标 Plan View - 不显示任何指示器，并且有自己的自定义指示器部分用于计划状态值 Other Views - 不显示车辆模式指示 定制的可能性指示器您可以添加自己的指标显示或删除任何上游指标。您使用的机制取决于指示器类型。 App Indicators这些向用户提供的信息与车辆无关。例如RTK状态。使用 QGCPlugin::toolbarIndicators 来操作应用程序指标列表 Vehicle Indicators这些是与车辆信息相关的指示器。它们只有在车辆联网时才可用。要操作车辆指标列表，您可以覆盖 FirmwarePlugin::toolIndicators 。 Vehicle Mode Indicators这些是与车辆信息相关的指示器。它们需要Fly View提供的额外UI来完成它们的操作。Arming and Disarming《武装与解除武装》就是一个例子。它们只有在车辆联网时才可用。要操作车辆模式指标列表，您可以覆盖FirmwarePlugin::modeIndicators 。 修改工具栏UI本身这是通过在与工具栏关联的qml文件上使用资源覆盖来实现的。这提供了高级别的定制，但也增加了复杂性。工具栏的主要用户界面在 MainToolBar.qml 中。主窗口代码MainRootWindow.qml与工具栏交互，根据当前视图显示不同的指示符部分，以及模式指示符是否显示也基于当前视图。 如果你想完全控制工具栏，那么你可以重写MainToolBar.qml，并制作自己完全不同的版本。您需要特别注意主工具栏与MainRootWindow.qml的交互。因为您将需要在自己的自定义版本中复制这些交互。 工具栏有两个标准的指示器ui部分: MainToolBarIndicators.qml这用于除Plan之外的所有视图。以一行方式显示所有指标。虽然您可以覆盖这个文件，但实际上它除了为指示器布局之外并没有做什么。 PlanToolBarIndicators.qmlPlan视图使用它来显示状态值。如果您想更改ui，您可以覆盖该文件并提供您自己的自定义版本。 飞行视图定制Fly View是这样设计的，它可以从简单到更复杂的多种方式进行定制。它被设计成三个独立的层，每个层都是可定制的，提供不同级别的更改 Layers 从上到下视觉上有三层: FlyView.qml 这是ui和业务逻辑的基础层，用于控制地图和视频切换。 FlyViewWidgetsOverlay.qml 这一层包括飞行视图的所有剩余小部件。 FlyViewCustomLayer.qml 这是一个图层，您可以使用资源覆盖来添加自己的自定义图层。 Inset Negotiation using QGCToolInsetsFly View的一个重要方面是，它需要了解它的地图窗口中间有多少中央空间，这些空间没有被窗口边缘的ui小部件所阻碍。当车辆从视野中消失时，它会利用这些信息平移地图。这不仅需要对窗口边缘进行操作，还需要对小部件本身进行操作，以便地图在进入小部件下面之前平移。 这是通过使用 QGCToolInsets 对象包含在每一层。该对象为每个窗口边缘提供插入信息，告知系统基于边缘的ui占用了多少空间。每个图层都通过parentToolInsets获得下面图层的插图，然后通过“toolInsets”报告新的插图，考虑到下面的图层和它自己的添加。然后将最终结果总插入值提供给地图，以便它可以做正确的事情。理解这一点的最好方法是查看上游和自定义示例代码。 FlyView.qml从ui交互和业务逻辑来看，视图的基础层也是最复杂的。它包括地图和视频的主要显示元素以及引导控件。尽管您可以覆盖此层，但不建议这样做。如果你这样做，你最好真的知道你在做什么。它是一个单独的层的原因是使上面的层更简单，更容易定制。 FlyViewWidgetsOverlay.qml这一层包含飞行视图的所有剩余控件。你可以通过使用 QGCFlyViewOptions 隐藏控件。但是，为了更改上游控件的布局，您必须使用资源覆盖。如果你查看源代码，你会发现控件本身被很好地封装，因此创建自己的重写来重新定位它们和/或添加自己的ui应该不是那么困难。同时保持与控件的上游实现的连接。 FlyViewCustomLayer.qml这为Fly View提供了最简单的自定义能力。允许您添加ui元素，添加到现有的上游控件。上游代码没有添加ui元素，它是您自己的自定义代码的基础，用作此qml的资源覆盖。自定义示例代码为您提供了如何执行此操作的示例。 推荐规范简单的定制最好的开始是使用自定义层覆盖加上关闭widget层的ui元素(如果需要的话)。如果可能的话，我建议只坚持这样做。它提供了最大的能力，不会被下面层中的上游更改搞砸。 中等复杂度定制如果你真的需要重新定位上游ui元素，那么你唯一的选择是重写 flyviewwidgetoverlay .qml 。通过这样做，您可以将自己与上游变化保持一定距离。尽管您仍然可以免费获得上游控件的更改。如果有一个全新的控件被添加到飞行视图的上游，你不会得到它，直到你把它添加到你自己的覆盖。 高度复杂的定制最后也是最不推荐的定制机制是重写 FlyView.qml 。通过这样做，您将进一步远离免费获得上游更改 自定义构建的发布过程[WIP文档]创建您自己的自定义构建的一个更棘手的方面是使其与常规QGC保持同步的过程。本文档描述了建议遵循的流程。但实际上，我们欢迎您为定制构建使用任何分支和发布策略。 Upstream QGC release/branching strategyThe best place to start is understanding the mechanism QGC uses to do it’s own releases. We will layer a custom build release process on top of that. You can find standard QGC release process here. Custom build/release typesRegular QGC has two main build types: Stable and Daily. The build type for a custom build is more complex. Throughout this discussion we will use the term “upstream” to refer to the main QGC repo (https://github.com/mavlink/qgroundcontrol). Also when we talk about a “new” upstream stable release, this means a major/minor release, not a patch release. Synchronized StableThis type of release is synchronized with the release of an upstream stable. Once QGC releases stable you then release a version of your custom build which is based on this stable. This build will include all the new features from upstream including the new feature in your own custom code. Out-Of-Band StableThis a subsequent release of your custom build after you have released a synchronized stable but prior to upstream releasing a new stable. It only includes new features from your own custom build and include no new features from upstream. Work on this type of release would occur on a branch which is either based on your latest synchronized stable or your last out of band release if it exists. You can release out of band stable releases at any time past your first synchronized stable release. DailyYour custom daily builds are built from your branch. It is important to keep your custom master up to date with QGC master. If you lag behind you may be surprised by upstream features which require some effort to integrate with your build. Or you may even require changes to “core” QGC in order to work with your code. If you don’t let QGC development team know soon enough, it may end up being too late to get things changed.master Options for your first buildStarting with a Synchronized Stable releaseIt is suggested that you start with releasing a Synchronized Stable. This isn’t necessary but it is the simplest way to get started. To set your self up for a synchronized stable you create your own branch for development which is based on the upstream current stable. Starting with Daily buildsThe reason why you may consider this as your starting point is because you need features which are only in upstream master for your own custom builds. In this case you will have to live with releasing custom Daily builds until the next upstream stable. At which point you would release you first Synchronized Stable. For this setup you use your master branch and keep it in sync with upstream master as you develop. After you release your first Synchronized StablePatch ReleasesAs upstream QGC does patch releases on Stable you should also release your own patch releases based on upstream to keep your stable up to date with latest criticial bug fixes. Out-Of-Band, Daily: One or the other or both?At this point you can decide which type of releases you want to follow. You can also decide to possibly do both. You can do smaller new features which don’t require new upstream features using out of band releases. And you can do major new feature work as daily/master until the point you can do a new synchronized stable. MAVLink 定制QGC使用MAVLink与飞行堆栈通信，这是一种为无人机生态系统设计的非常轻量级的消息传递协议。QGC默认包含ArduPilotMega.xml语言，它允许它与PX4和Ardupilot (PX4使用common.xml，它包含在ArduPilotMega中)进行通信。 为了增加对一组新消息的支持，您最终需要将它们添加到或分叉QGroundControl并包含您自己的语言。ArduPilotMega.xml common.xml To do this: 替换预构建的C库/qgroundcontrol/libs/mavlink/include/mavlink。 默认情况下，这是一个子模块导入https://github.com/mavlink/c_library_v2 你可以改变子模块，或建立自己的库使用MAVLink工具链。 当运行qmake时，您可以通过在MAVLINK_CONF中设置所使用的整个语言。 参考链接：Overview · QGroundControl Developer Guide","link":"/2023/05/10/QGC%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"QThread使用方法","text":"实例化QThread这个类会开辟一个新线程，默认运行run()，还可以使用QObject::moveToThread方法将任务对象移动至新线程，此时该任务对象的槽函数将运行在新线程中，可以自由的建立相关信号连接，默认是以Qt::QueuedConnection方式，是线程安全的。 这样，我们可以有几种方式来创建线程完成工作： 任务对象继承QThread，重写run()方法；实例化对象后会自动运行run()函数工作 任务对象继承QObject，将工作任务实现在这个类的槽中； 创建QThead，自定义类调用QObject::moveToThread方法移动至新开辟的线程； 绑定该任务对象的槽，任意信号触发时，将在新线程中执行槽函数； example方法1： 12345678910111213141516171819class WorkerThread : public QThread{ Q_OBJECT void run() override { QString result; /* ... here is the expensive or blocking operation ... */ emit resultReady(result); }signals: void resultReady(const QString &amp;s);};void MyObject::startWorkInAThread(){ WorkerThread *workerThread = new WorkerThread(this); connect(workerThread, &amp;WorkerThread::resultReady, this, &amp;MyObject::handleResults); connect(workerThread, &amp;WorkerThread::finished, workerThread, &amp;QObject::deleteLater); workerThread-&gt;start();} 方法2： 12345678910111213141516171819202122232425262728293031323334353637class Worker : public QObject{ Q_OBJECTpublic slots: void doWork(const QString &amp;parameter) { QString result; /* ... here is the expensive or blocking operation ... */ emit resultReady(result); }signals: void resultReady(const QString &amp;result);};class Controller : public QObject{ Q_OBJECT QThread workerThread;public: Controller() { Worker *worker = new Worker; worker-&gt;moveToThread(&amp;workerThread); connect(&amp;workerThread, &amp;QThread::finished, worker, &amp;QObject::deleteLater); connect(this, &amp;Controller::operate, worker, &amp;Worker::doWork); connect(worker, &amp;Worker::resultReady, this, &amp;Controller::handleResults); workerThread.start(); } ~Controller() { workerThread.quit(); workerThread.wait(); }public slots: void handleResults(const QString &amp;);signals: void operate(const QString &amp;);};","link":"/2023/04/13/QThread%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"Qt MVC模型","text":"介绍详见Qt文档 Model/View Programming 模型Model提供数据，视图View负责呈现模型数据，并负责处理用户输入。委托增加了输入的灵活性，提供输入功能，负责呈现视图中的单个项。 Model：创建自定义模型 详见Qt文档 Model/View Programming/Creating New Models 自定义列表模型：子类化QAbstractListModel 设置自定义列表数据 QList&lt;T&gt; datas_; 重写rowCount() 和 data() 1234// 计算列表总数virtual int rowCount(const QModelIndex &amp;parent = QModelIndex()) const = 0;// 根据索引、自定义枚举 提取数据virtual QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const = 0; 如果需要编辑，重写setData() 和 removeRows() 12virtual bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role = Qt::EditRole); virtual bool removeRows(int row, int count, const QModelIndex &amp;parent = QModelIndex()); 其他列表模型 12345// 为树和表视图提供标头信息virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;// 分层模型必须实现virtual QModelIndex index(int row, int column, const QModelIndex &amp;parent = QModelIndex()) const = 0;virtual QModelIndex parent(const QModelIndex &amp;index) const = 0; 自定义排序筛选模型：子类化 QSortFilterProxyModel 排序筛选模型依赖源数据模型，根据指定规则进行排序筛选。 可以链接到任何类型的视图，并在视图之间共享。 每个数据是从源模型中的 原始位置，映射 到代理模型中的不同位置。 视图使用代理模型提供的模型索引访问项，这些索引不包含源模型原始项的位置信息（即使用代理模型的话，视图提供的索引信息都是代理的模型数据，即原始位置的映射） 自定义筛选规则 1virtual bool filterAcceptsRow(int source_row, const QModelIndex &amp;source_parent) const; 自定义排序规则 1virtual bool lessThan(const QModelIndex &amp;source_left, const QModelIndex &amp;source_right) const; Delegate: 创建自定义委托 官方建议视图不要共用委托 自定义Item委托，子类化QStyledItemDelegate 根据索引画出item 1virtual void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override; 设置item大小 1virtual QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const override; 编辑事件，只包含鼠标事件，可以实现右键菜单或按钮点击等 1virtual bool editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) override; View：视图 继承QAbstractItemView的视图有一些默认信号 12345678signals: void activated(const QModelIndex &amp;index); void clicked(const QModelIndex &amp;index); void doubleClicked(const QModelIndex &amp;index); void entered(const QModelIndex &amp;index); void iconSizeChanged(const QSize &amp;size); void pressed(const QModelIndex &amp;index); void viewportEntered(); 使用Qt自带的视图基本满足需求：QListView， QTreeView Example demo源码： qt_demo/mvc_test at main · cccccrz/qt_demo (github.com)","link":"/2023/04/13/Qt-MVC%E6%A8%A1%E5%9E%8B/"},{"title":"QML模块化管理","text":"Module Definition qmldir Files 目录示例 1.项目目录创建src存放代码文件 src/QmlControl/ 存放QML文件，在此目录下创建QML模块，目录为模块名，每个模块下创建一个qmldir 2.qmldir基本语法：文件开头第一行声明模块名，&lt;ModuleIdentifier&gt;是模块的标识符(带点的URI符号)，它必须与模块的安装路径匹配。 后续声明文件导入URI 版本号 文件名，详见Qt文档 1234module &lt;ModuleIdentifier&gt; &lt;ResourceIdentifier&gt; &lt;InitialVersion&gt; &lt;File&gt;... exampleqmldir 12345module ExampleModuleCustomButton 2.0 CustomButton20.qmlCustomButton 2.1 CustomButton21.qmlplugin examplemoduleMathFunctions 2.0 mathfuncs.js qml文件使用模块 1234567891011121314import QtQuick 2.0import ExampleModule 2.1Rectangle { width: 400 height: 400 color: &quot;lightsteelblue&quot; CustomButton { color: &quot;gray&quot; text: &quot;Click Me!&quot; onClicked: MathFunctions.generateRandom() &gt; 10 ? color = &quot;red&quot; : color = &quot;gray&quot;; }} 3.pro工程文件导入QML模块路径此参数影响qtcreator识别模块类型，不影响编译 1QML_IMPORT_PATH += $$PWD/src/QmlControl 4.创建qrc资源文件根目录创建qmlcontrol.qrc资源文件，单独管理qml，前缀该为qml导入目录 /QmlControl 5.创建QML模块创建qml文件./src/QmlControl/M1/MyButton1.qml，加入 qmlcontrol.qrc 开始模块管理： 打开资源文件，将该文件别名改为: 模块/文件名 将该模块目录下的qmldir加入资源文件，同样修改别名 修改该模块下的qmldir 123Module M1MyButton 1.0 MyButton.qml 主窗口文件可以放在 ./src/QmlControl/mainWindow.qml，QML导入路径根目录 5.cpp导入QML模块路径QQmlApplicationEngine::addImportPath 导入模块路径 当前模块路径为 qrc:/QmlControl 6.cpp加载QMLQQmlApplicationEngine::load 加载QML文件 当前加载主窗口 qrc:/QmlControl/mainWindow.qml 7.QML文件使用QML模块主窗口使用 1234567891011121314import QtQuick 2.12import QtQuick.Window 2.12import M1 1.0 // 导入模块Window { id: mainWindow visible: true width: 640 height: 480 title: qsTr(&quot;Hello World&quot;) MyButton { // 使用模块内QML部件 }}","link":"/2023/06/09/QML%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%A1%E7%90%86/"},{"title":"Qt错误日志","text":"1. qtcreator 卡死 参考QT 5.12和有道词典冲突","link":"/2023/06/09/Qt%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"},{"title":"mavlink环境搭建","text":"本机环境：系统：银河麒麟V10(SP1) 2203 x86_64 1. 获取源码12345678# Dependenciessudo apt install python3-pip# Clone mavlink into the directory of your choicegit clone https://github.com/mavlink/mavlink.git --recursivecd mavlinkpython3 -m pip install -r pymavlink/requirements.txt 2. 安装12cmake -Bbuild -H. -DCMAKE_INSTALL_PREFIX=installcmake --build build --target install 头文件在 install/include 里 3. 构建示例123cd examples/ccmake -Bbuild -H. -DCMAKE_PREFIX_PATH=$(pwd)/../../installcmake --build build 1python3 -m pymavlink.tools.mavgen --lang=C --wire-protocol=2.0 --output=./include/ message_definitions/v1.0/common.xml 官方手册：Install MAVLink · MAVLink Developer Guide","link":"/2023/05/08/mavlink%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"qt增加右键菜单","text":"示例 普通widget增加右键菜单，增加事件过滤器即可 1234567891011121314151617181920212223242526272829QWidget::eventFilter(QObject* obj, QEvent* e) { if (QEvent::MouseButtonPress == e-&gt;type()) { if (Qt::RightButton == event-&gt;button()) { CreateMenu(event-&gt;globalPos()); } }}void CreateMenu(const QPoint&amp; pos){ QMenu* menu = new QMenu(/*parent*/); QAction* action1 = new QAction(&quot;a1&quot;, menu); QAction* action2 = new QAction(&quot;a2&quot;, menu/*, SLOT()*/); menu-&gt;addAction(aciton1); menu-&gt;addSeparator(); menu-&gt;addAction(action2); connect(menu, SIGNAL(triggered(QAction*)), this, SLOT(OnMenuTrigged(QAction*))); // 同步#if 1 menu-&gt;exec(pos); delete menu;#else // 异步 menu-&gt;setAttribute(Qt::WA_DeleteOnClose); // 窗口关闭后自行析构 menu-&gt;popup(pos);#endif} 默认的菜单事件 [virtual protected] void QWidget::contextMenuEvent(QContextMenuEvent *event) 部分控件可以重写该函数，实现自定义菜单","link":"/2023/04/13/qt%E5%A2%9E%E5%8A%A0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"},{"title":"Qt工程文件","text":"记录Qt工程文件实用语法 打印信息message() 打印信息 !build_pass: 防止重复打印 12# 打印变量!build_pass:message('------------- $$PWD -------------') 增加预编译宏12win32:CONFIG(debug, debug|release): DEFINES += DEBUGelse:win32:CONFIG(release, debug|release): DEFINES += RELEASE QMAKE_POST_LINK 链接前执行 12345# 链接前拷贝LIB_FILE = xx/xx/xxLIB_BIN_PATH = xx/xxwin32: QMAKE_POST_LINK += copy /Y $$LIB_FILE $$LIB_BIN_PATHelse:unix: QMAKE_POST_LINK += cp $$LIB_FILE $$LIB_BIN_PATH 指定目标生成路径1234BULID_PATH = $$PWD/binwin32:CONFIG(debug, debug|release): BULID_PATH = $$BULID_PATH/debugelse:win32:CONFIG(release, debug|release): BULID_PATH = $$BULID_PATH/releaseDESTDIR = $$BULID_PATH 递归添加源文件12345678910111213SourceDir = \\ $$PWD/common \\ $$PWD/mainfor(var, SourceDir) { SOURCES += $$files($$join(var, , , /*.cpp), true) HEADERS += $$files($$join(var, , , /*.h), true) FORMS += $$files($$join(var, , , /*.ui), true)}# 去重SOURCES = $$unique(SOURCES)HEADERS = $$unique(HEADERS)INCLUDEPATH += $$dirname(SOURCES)INCLUDEPATH = $$unique(INCLUDEPATH) 添加库依赖12345678910111213141516171819ARCH = x86_64PLANTFORM = linuxLibPaths = \\ $$PWD/xxx1/$$PLANTFORM/$$ARCH \\ $$PWD/xxx2/$$PLANTFORM/$$ARCHfor(var, LibPaths) { LibName = $$files($$join(var, , , /*.so), true) # 取库名 LibName = $$basename(LibName) # 去掉后缀, libxxx.so, 换成 -lxxx LibName = $$replace(LibName, $$quote(.so), ) LibName = $$replace(LibName, $$quote(\\.a), ) #LibName = $$replace(LibName, lib, -l) # 取库路径 LibPath = $$dirname(var) #LibPath = $$join(LibPath, $$quote(&quot; -L&quot;), -L, ) #添加库 LIBS += -L$$LibPath -l$$LibName} 指定缓存路径1234UI_DIRRCC_DIRMOC_DIROBJECTS_DIR 指定版本Qt设置程序版本等信息以及乱码问题 123456VERSION = 1.2.3QMAKE_TARGET_PRODUCT = 产品名称QMAKE_TARGET_COMPANY = 公司QMAKE_TARGET_DESCRIPTION = 文件描述QMAKE_TARGET_COPYRIGHT = 版权 构建生成rc文件，删除上面代码添加RC文件 1RC_FILE=TEST_resource.rc 函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556message()功能：常用的pro打印，类似printf，Qt5中可以使用（Qt4不知道为什么不能用，可以在Qt5上调试好后放到Qt4上）示例： message(&quot;My Source Files have $$SOURCES&quot;) 将会打印出 My Source Files have ./src/main.cpp ./src/func.cpp提示：有什么奇奇怪怪的想法可以用message来进行打印出来验证$$files(1, 2) 功能：递归搜索文件参数： 1：搜寻的文件模板路径有.cpp文件 2：是否递归搜索，true - 是， false - 否示例： Sample = ./src/*.cpp $$files(Sample, true) 返回 ./src/main.cpp ./src/func.cpp$$join(1, 2, 3, 4) 功能：变量拼接内容参数： 1：变量 2：“胶水”，在多变量之间拼接上去的词 3：头部拼接 4：尾部拼接示例1： Sample = LibName $$join(Sample, , , .so) 返回 LibName.so示例2： Sample = Dxf $$join(Sample, , -l, ) 返回 -lDxf$$section(1, 2, 3, 4)功能：字符串节选参数： 1：字符串 2：分割号 3：开始段 4：结束段示例： Sample = LibSample.so $$section(Sample, ., 0, 0) 返回 LibSample$$dirname功能：返回文件的路径，不带文件名的$$basename功能：返回文件名，不带路径的$$unique功能：去掉重复的变量","link":"/2023/04/13/qt%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6/"},{"title":"qt剪贴板","text":"全局剪贴板剪贴板数据更新时发送信号 1[signal] void QClipboard::dataChanged(); 获取剪贴板数据 123const QMimeData *mimeData(QClipboard::Mode mode = Clipboard) const;//QApplication::clipboard()-&gt;mimeData(); 设置剪贴板数据 123void setMimeData(QMimeData *src, QClipboard::Mode mode = Clipboard);//QApplication::clipboard()-&gt;setMimeData(mimedata); QMimeDataQMimeData 存储剪贴板数据 通常由对象 QDrag 和 QClipboard 使用 Tester Getter Setter MIME Types hasText() text() setText() text/plain hasHtml() html() setHtml() text/html hasUrls() urls() setUrls() text/uri-list hasImage() imageData() setImageData() image/ * hasColor() colorData() setColorData() application/x-color example1234567891011121314void MyWidget::dragEnterEvent(QDragEnterEvent *event){ if (event-&gt;mimeData()-&gt;hasUrls()) event-&gt;acceptProposedAction();}void MyWidget::dropEvent(QDropEvent *event){ if (event-&gt;mimeData()-&gt;hasUrls()) { foreach (QUrl url, event-&gt;mimeData()-&gt;urls()) { ... } }} 存储自定义数据 Custom data can be stored directly in a QMimeData object as a QByteArray using setData(). For example: 123QByteArray csvData = ...;QMimeData *mimeData = new QMimeData;mimeData-&gt;setData(&quot;text/csv&quot;, csvData); We can subclass QMimeData and reimplement hasFormat(), formats(), and retrieveData(). If the drag and drop operation occurs within a single application, we can subclass QMimeData and add extra data in it, and use a qobject_cast() in the receiver’s drop event handler. For example: 12345678void MyWidget::dropEvent(QDropEvent *event){ const MyMimeData *myData = qobject_cast&lt;const MyMimeData *&gt;(event-&gt;mimeData()); if (myData) { // access myData's data directly (not through QMimeData's API) }} QTextEdit文本输入框的粘贴 重写该函数，返回值决定是否允许粘贴 1[virtual protected] bool QTextEdit::canInsertFromMimeData(const QMimeData *source) const 重写该函数，自定义粘贴 1[virtual protected] void QTextEdit::insertFromMimeData(const QMimeData *source)","link":"/2023/04/13/qt%E5%89%AA%E8%B4%B4%E6%9D%BF/"},{"title":"qt解析封装json","text":"记录Qt的JSON解析封装用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051QString PackWithUuid(const QJsonObject&amp; obj){ if (obj.isEmpty()) return QString(); obj[&quot;uuid&quot;] = &quot;uuid&quot;; QJsonDocument doc(obj); return doc.toJson(QJsonDocument::Compact);}QString PackJson(const QString&amp; text){ QJsonObject obj; QJsonObject htmlObj; htmlObj[&quot;text&quot;] = text; // array QJsonArray array; for (int i=0; i&lt;5; ++i) { array.append(i); } htmlObj[&quot;array&quot;] = array; obj[&quot;html&quot;] = htmlObj; return PackWithUuid(obj);}bool ParseJson(const QByteArray&amp; json, QString&amp; text){ QJsonParseError jsonError; QJsonDocument doc = QJsonDocument::fromJson(json, &amp;jsonError); if (jsonError.error != QJsonParseError::NoError) { return false; } if (doc.isObject()) { QJsonObject obj = doc.object(); if (obj.contains(&quot;html&quot;)) { if (obj[&quot;html&quot;].isObject()) { QJsonObject htmlObj = obj[&quot;html&quot;].toObject(); if (htmlObj.contains(&quot;text&quot;)) { if (htmlObj[&quot;text&quot;].isString()) text = htmlObj[&quot;text&quot;].toString(); } if (htmlObj.contains(&quot;array&quot;)) { if (htmlObj[&quot;array&quot;].isArray()) { QJsonArray array = htmlObj[&quot;array&quot;].toArray(); } } } } } return true;}","link":"/2023/04/13/qt%E8%A7%A3%E6%9E%90%E5%B0%81%E8%A3%85json/"},{"title":"qt富文本生成&amp;解析","text":"富文本结构详见Qt文档：Rich Text Document Structure Qt里QTextDocument类提供了富文本支持，可以使用setHtml()设置富文本，使用toHtml()获取富文本。 1.自定义对象QTextObjectInterface类允许在QTextDocument类中增加自定义对象 实现详见QTextObjectInterface Class 继承 QObject 和 &lt;QTextObjectInterface&gt; 12345class SvgTextObject : public QObject, public QTextObjectInterface{ Q_OBJECT Q_INTERFACES(QTextObjectInterface)... 实现两个接口函数 1234// 对象呈现样式，用painter画出来virtual void drawObject(QPainter *painter, const QRectF &amp;rect, QTextDocument *doc, int posInDocument, const QTextFormat &amp;format) = 0;// 自定义对象大小virtual QSizeF intrinsicSize(QTextDocument *doc, int posInDocument, const QTextFormat &amp;format) = 0 注册 注册自定义枚举 12345678910// 对象枚举enum MyTextObject{ kMyObject = QTextFormat::UserObject + 1};// 属性枚举enum MyTextProperty{ kMyProperty = QTextFormat::UserProperty + 1}; 注册自定义对象 void QAbstractTextDocumentLayout::registerHandler(int objectType, QObject *component) 1234QTextEdit* editor = new QTextEdit(/*parent*/);SvgTextObject* handle = new SvgTextObject;handle-&gt;setParent(editor);editor-&gt;document()-&gt;documentLayout()-&gt;registerHandler(kMyObject, handle); 插入 设置对象属性 1234T info; // 对象携带信息QTextCharFormat format;format.setObjectType(kMyObject);format.setProperty(kMyProperty, QVariant::fromValue(info)); 插入 123QTextCursor tc = editor-&gt;textCursor();tc.insertText(QString(QChar::ObjectReplacementCharacter), format);editor.setTextCursor(tc); 2.图片插入法1：使用html语言 1234QString html_text;html_text.append(&quot;&lt;img src=\\&quot;%1\\&quot; width=\\&quot;%2\\&quot; height=\\&quot;%3\\&quot; /&gt;&quot;).arg(img_name).arg(img_width).arg(img_height);QTextDocument doc;doc.setHtml(html_text); 法2：使用QTextCursor 插入 QTextImageFormat 123456789101112131415161718192021// QImage image 图片资源 QTextImageFormat image_format;image_format.setName(name);image_format.setWidth(w);image_format.setHeight(h);// 如果需要锚点，可以设置image_format.setAnchor(true);image_format.setAnchorHref(name);// 图片布局image_format.setVerticalAlignment(QTextCharFormat::VerticalAlignment);// 相同名字的图片解析时只会触发一次，暂时设置唯一标识避免image_format.setAnchorName(Util::GenUuid());// 加入资源editor-&gt;document()-&gt;addResource(QTextDocument::ImageResource, name, QVariant(image));// 插入图片editor()-&gt;textCUrsor().insertImage(image_format);// 解决后续输入文本也是超链接QTextCharFormat format;format.setAnchor(false);format.setForeground(Qt::black);editor-&gt;setCurrentCharFormat(format); 3.UI交互可以根据鼠标位置获取锚点 1QString QTextEdit::anchorAt(const QPoint &amp;pos) const 删除鼠标位置元素 12345678910111213141516171819202122232425void MyTextEdit::RemoveChar(const QPoint&amp; pos) // pos 鼠标位置 event-&gt;pos(){ QTextCurosr tc = cursorForPosition(pos); // 鼠标位置在元素的左半部分和右半部分点击获取的光标位置不同 // 比较anchor, 不匹配，删除position后一个；匹配，删除position前一个 do { if (tc.position() == 0) { tc.deleteChar(); break; } QTextCharFormat format = tc.charFormat(); QString source_name = anchorAt(pos); QString anchor_name; if (QTextFormat::ImageObject == format.objectType()) { anchor_name = format.toImageFormat().name(); } // else if 自定义类型 if (anchor_name == source) { tc.deletePreviousChar(); } else { tc.deleteChar(); } } while (0); setTextCursor(tc);} 4.富文本解析QTextDocument的基本结构如图： 依次遍历便可解析： 1234567891011121314151617181920212223242526272829303132333435// 文本块处理void processBlock(const QTextBlock&amp; textBlock){ QTextCharFormat format; for (auto it = textBlock.begin(); !it.atEnd(); ++it) { if (!it.fragment().isValid()) continue; // format里包含片段的属性，属性相同为一个片段，所以相邻的相同格式、名字的图片，只会有一个片段 format = it.fragment().charFormat(); // format.objectType() 自定义对象类型/qt对象类型 if (QTextFormat::ImageObject == format.objectType()) { // 图片 format.toImageFormat().name(); // QTextImageFormat() 图片format //获取图片信息 QTextImageFormat::name() /width() /height() } else if (QTextFormat::NoObject == format.objectType()) { // 文本类型 it.fragment().text(); // 文本 } // else 其他文本对象类型 QTextFormat::UserObject + ... }}// 文档处理void parseDocument(QTextDocument* doc){ QTextBlock currentBlock = doc-&gt;begin(); while (currentBlock.isValid()) { // 是否有效， true 为有效 processBlock(currentBlock); currentBlock = currentBlock.next();#if 0 // 如果需要判断是否换行 if (currentBlock.isValid()) { // 此处换行 }#endif }}","link":"/2023/04/13/qt%E5%AF%8C%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90&%E8%A7%A3%E6%9E%90/"},{"title":"qt设置程序信息","text":"记录qt设置程序信息方法 Qt设置程序版本等信息以及乱码问题在.pro文件中加入 123456VERSION = 1.2.3QMAKE_TARGET_PRODUCT = 产品名称QMAKE_TARGET_COMPANY = 公司QMAKE_TARGET_DESCRIPTION = 文件描述QMAKE_TARGET_COPYRIGHT = 版权 使用MSVC编译器会出现中文乱码，必须使用GBK进行编码。下一步，通过notepad++打开文件生成目录中的.rc文件，通常文件名为：项目名_resource.rc 本文件是在项目qmake时自动生成的。切换ANSI编码后乱码，由此验证了我们的编码是utf-8，而显示需要GBK：保持ANSI编码，将乱码文字替换：在.pro文件加入，并可将上面设置注释： 1234567#VERSION = 1.2.3#QMAKE_TARGET_PRODUCT = 产品名称#QMAKE_TARGET_COMPANY = 公司#QMAKE_TARGET_DESCRIPTION = 文件描述#QMAKE_TARGET_COPYRIGHT = 版权RC_FILE=TEST_resource.rc qmake-&gt;build后，查看.exe： 总结1、通过设置系统变量 VERSION 或 RC_ICONS （至少一个），qmake 会自动生成 .rc 文件。以 VERSION 为例，在 pro 中添加版本信息： 1VERSION = 1.2.3 执行 qmake，这时，会在 build 目录下生成一个名为 MyApp_resource.rc 的文件，生成的 .rc 文件会被自动编译和链接.2、用Notepad++打开 切换ANS1编码，修改中文 3、在.pro文件中删除VERSION，并添加 12#VERSION = 1.2.3 //注释或删除RC_FILE=TEST_resource.rc 4、重新执行qmake,build，可完成 注意：如果设置了 RC_FILE 或 RES_FILE，qmake 对 .rc 文件的生成就失效了。这种情况下，qmake 不会对指定的 .rc 文件或 .res 或 .o 文件作进一步更改，有关 .rc 文件生成的变量不会有任何效果。 参考文章:Qt设置程序版本等信息以及乱码问题_qt 设置版本_会飞的花斑猪的博客-CSDN博客","link":"/2023/04/13/qt%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E4%BF%A1%E6%81%AF/"},{"title":"qt踩坑","text":"记录实用Qt遇到的坑以及解决方案 Qt Error1. qt explicit qualification in declaration已经存在在命名空间内，再声明函数或者类不要再加限定符，去掉函数前的XX:: 2. QT5.14.2 + MSCV2015 报错：error: C2661: “QColor::CT::CT”: 没有重载函数接受 5 个参数解决方案 保留VisualStudio2015，卸载QT5.14.2. 重新下载其它QT版本，例如（5.12.9），采用MSVC2015 编译器，没有报错 QDialog 最小化后调用 show() 无法显示使用 showNormal() 恢复","link":"/2023/04/13/qt%E8%B8%A9%E5%9D%91/"},{"title":"windows10 git等状态图标不显示","text":"IconOverlay，图标覆盖，常用于在文件（夹）上显示状态图标。 原因：Windows 支持最多15个 Overlay Icon，而它们按字符顺序排列，排在前15个的项是有效的，之后的就失效了。 解决方案：需要修改注册表，打开regedit.exe 增加图标缓存 位置：计算机\\HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer 新建一个字符串值名称为 Max Cached Icons 值是 4096 ，可以自定义，适当调大可以改善图标加载速度 将需要显示的图标放在最前面 位置 ：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers 修改图标名称，增加空格就会排在前面 改完注册表后，记得重启。","link":"/2023/04/17/windows10-git%E7%AD%89%E7%8A%B6%E6%80%81%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"},{"title":"定制qtcreator","text":"定制界面主题主题位置 1%appdata%\\QtProject\\qtcreator\\styles 定制代码风格自定义snippets 1%appdata%\\QtProject\\qtcreator\\snippets 预览","link":"/2023/05/08/%E5%AE%9A%E5%88%B6qtcreator/"},{"title":"数据结构-1 二叉树","text":"学习日志 树定义树（Tree） 是n(n&gt;=0)个结点的有限集。n=0时称为空树。在任意一颗非空树中： 有且仅有一个特定的称为根（Root）的结点； 当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。 此外，树的定义还需要强调以下两点： n&gt;0时根结点是唯一的，不可能存在多个根结点，数据结构中的树只能有一个根结点。 m&gt;0时，子树的个数没有限制，但它们一定是互不相交的。 节点结点是数据结构中的基础，是构成复杂数据结构的基本组成单位。 结点的度结点拥有的子树数目称为结点的度。 结点关系 结点子树的根结点为该结点的孩子结点。相应该结点称为孩子结点的双亲结点。 同一个双亲结点的孩子结点之间互称兄弟结点。 如图：A为B的双亲结点，B为A的孩子结点。 结点B与结点C互为兄弟结点。 结点层次 从根开始定义起，根为第一层，根的孩子为第二层，以此类推。 树的深度 树中结点的最大层次数称为树的深度或高度。 如图树的深度为4。 二叉树定义二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。 图解 二叉树特点由二叉树定义以及图示分析得出二叉树有以下特点： 每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。 左子树和右子树是有顺序的，次序不能任意颠倒。 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 二叉树性质由二叉树定义以及图示分析得出二叉树有以下性质： 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性： 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点; 若 2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点； 若 2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。 斜树定义斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 满二叉树图解 定义满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 满二叉树的特点满二叉树的特点有： 叶子只能出现在最下一层。出现在其它层就不可能达成平衡。 非叶子结点的度一定是2。 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。 完全二叉树图解 定义完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 完全二叉树特点特点： 叶子结点只能出现在最下层和次下层。 最下层的叶子结点集中在树的左部。 倒数第二层若存在叶子结点，一定在右部连续位置。 如果结点度为1，则该结点只有左孩子，即没有右子树。 同样结点数目的二叉树，完全二叉树深度最小。 注：满二叉树一定是完全二叉树，但反过来不一定成立。 二叉树的存储结构定义二叉树的顺序存储结构就是使用一维数组存储二叉树中的结点，并且结点的存储位置，就是数组的下标索引。 图解 如图一棵完全二叉树按照顺序存储： 二叉树遍历定义二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。 访问次序二叉树的访问次序可以分为四种： 前序遍历 根结点 &gt; 左子树 &gt; 右子树 中序遍历 左子树&gt; 根结点 &gt; 右子树 后序遍历 左子树 &gt; 右子树 &gt; 根结点 层序遍历 仅仅需按层次遍历就可以 参考文章:二叉树！！！数据结构与算法，大学期间没学会，现在终于搞明白了 - 掘金 (juejin.cn)","link":"/2023/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%20%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"数据结构-2 堆","text":"学习日志 )","link":"/2023/04/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-%E5%A0%86/"},{"title":"答疑解惑","text":"记录一些问题的解决方案，常用知识点，以及资源 QT样式表qt中css的属性 qt样式表 MQTT官方手册 https://www.eclipse.org/paho/files/mqttdoc/MQTTClient/html/index.html https://www.eclipse.org/paho/files/mqttdoc/MQTTAsync/html/index.html Linux资源包搜索Packages for Linux and Unix debian软件包 内核源码 Libeventlibevent 深入浅出 libevent编程疑难解答 libevnet学习笔记，异步非阻塞SOCKET,从初等到高等代码 libevent在windows下使用步骤详解 搜索引擎程序员盒子","link":"/2023/04/10/%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91/"},{"title":"算法入门-2 双指针","text":"学习日志 概述在数组和链表的问题里经常考察的两类问题：「滑动窗口」和「双指针」，其实「滑动窗口」也可以称为「双指针」。 循环不变量 循环前、中、后保持不变 「循环不变量」不是很高深的概念，在「算法」和「数据结构」的世界里，到处都有它的身影。 「循环不变量」是指我们在编写代码的过程中，要一直循序不变的性质，这样的性质是根据要解决的问题，由我们自己定义的。「循环不变量」是我们写对一个问题的基础，保证了在「初始化」「循环遍历」「结束」这三个阶段相同的性质，使得一个问题能够被正确解决。 力扣 27.移除元素 123456789101112131415161718class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int left = 0; int n = nums.size(); int right = n - 1; while (left &lt;= right) { if (nums[left] == val) { nums[left] = nums[right]; right--; } else { left++; } } return left; }}; 参考文章:滑动窗口和双指针-力扣","link":"/2023/04/07/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-2-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"算法入门-1 二分法","text":"学习日志 什么是二分查找二分查找是计算机科学中最基本、最有用的算法之一。 它描述了在有序集合中搜索特定值的过程。 二分查找中使用的术语： 目标 Target —— 你要查找的值索引 Index —— 你要查找的当前位置左、右指示符 Left，Right —— 我们用来维持查找空间的指标中间指示符 Mid —— 我们用来应用条件来确定我们应该向左查找还是向右查找的索引 Mid 取值方式： left + (right - left) / 2 防数据溢出 mid = (left + right) &gt;&gt; 1 成功的二分查找的 3 个部分 二分查找一般由三个主要部分组成： 预处理 —— 如果集合未排序，则进行排序。 二分查找 —— 使用循环或递归在每次比较后将查找空间划分为两半。 后处理 —— 在剩余空间中确定可行的候选者。 3个模板模板1 初始条件：left = 0, right = length 终止：left == right 向左查找：right = mid 向右查找：left = mid+1 属性 二分查找的最基础和最基本的形式。 查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。 不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。 123456789101112131415// 顺序数组 v = {0, 1, 2, 3, 4, ...} 查找目标 targetint left = 0;int right = v.size() - 1;while (left &lt;= right) { int mid = left +(right - left) / 2; if (v[mid] == target) return mid; else if (v[mid] &gt; target) { // 中间值比目标大 right = mid - 1; // 向左查找 } else { left = mid + 1; // 向右查找 }} // 退出条件 left &gt; right// 此时left为目标值接近的下标return -1; 模板2 初始条件：left = 0, right = length 终止：left == right 向左查找：right = mid 向右查找：left = mid+1 属性 一种实现二分查找的高级方法。 查找条件需要访问元素的直接右邻居。 使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。 保证查找空间在每一步中至少有 2 个元素。 需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。 123456789101112131415161718int binarySearch(vector&lt;int&gt;&amp; nums, int target){ if(nums.size() == 0) return -1; int left = 0, right = nums.size(); while(left &lt; right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target){ return mid; } else if(nums[mid] &lt; target) { left = mid + 1; } else { right = mid; } } // Post-processing: // End Condition: left == right if(left != nums.size() &amp;&amp; nums[left] == target) return left; return -1;} 模板3 初始条件：left = 0, right = length-1 终止：left + 1 == right 向左查找：right = mid 向右查找：left = mid 1234567891011121314151617181920212223int binarySearch(vector&lt;int&gt;&amp; nums, int target){ if (nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while (left + 1 &lt; right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { left = mid; } else { right = mid; } } // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1;} 参考文章: 二分查找 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 「算法」 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台","link":"/2023/04/06/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-1-%E4%BA%8C%E5%88%86%E6%B3%95/"},{"title":"网站搭建日志(2)","text":"Choice Your Theme! 一些主题： jelly icarus 完善的网站框架 icarus安装手册 amazing 基于icarus，完善一些功能 版本有点老了，新版本hexo用不了 amazingremake 基于amazing，更新 1git clone https://github.com/LittleYe233/hexo-theme-amazingremake.git themes/amazingremake 更新日志2023-4-17： 加入搜索引擎： 在首页第一个&lt;head&gt;后添加 1&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;codeva-qsPplL1XWF&quot; /&gt;&lt;meta name=&quot;msvalidate.01&quot; content=&quot;D54149A8F600241C8B234A1D99DDB81B&quot; /&gt; 目前加入百度和Bing 2023-4-10 ：本站更换为amazingremake主题 分享一下配置文件 _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: ONE PIECEsubtitle: 一个兴趣使然的coderdescription: Welcome to my space~keywords: ONE PIECEauthor: ttylanguage: zh-CNtimezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://cccccrz.github.io/permalink: ':year/:month/:day/:title/'permalink_defaults: nullpretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: ''filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: '' wrap: true hljs: falseprismjs: enable: false preprocess: true line_number: true tab_replace: ''# Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: '-date'# Category &amp; Tagdefault_category: uncategorizedcategory_map: nulltag_map: null# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports 'mtime', 'date', 'empty'# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the 'source/' folderinclude: nullexclude: nullignore: null# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/ icarustheme: amazingremake# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: git@github.com:cccccrz/cccccrz.github.io.git branch: develop _config.amazingremake.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379# Version of the configuration fileversion: 4.0.0# Icarus theme variant, can be &quot;default&quot; or &quot;cyberpunk&quot;variant: default# 网站logo的路径或URLlogo: ''# Page metadata configurationshead: # 网站图标的URL或路径 favicon: /img/T_emp.png # Open Graph metadata # https://hexo.io/docs/helpers.html#open-graph open_graph: # Page title (og:title) (optional) # You should leave this blank for most of the time title: # Page type (og:type) (optional) # You should leave this blank for most of the time type: # Page URL (og:url) (optional) # You should leave this blank for most of the time url: # Page cover (og:image) (optional) # You should leave this blank for most of the time image: # Site name (og:site_name) (optional) # You should leave this blank for most of the time site_name: # Page author (article:author) (optional) # You should leave this blank for most of the time author: # Page description (og:description) (optional) # You should leave this blank for most of the time description: # Twitter card type (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter Site (twitter:site) twitter_site: # Google+ profile link (deprecated) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: # Structured data of the page # https://developers.google.com/search/docs/guides/intro-structured-data structured_data: # Page title (optional) # You should leave this blank for most of the time title: # Page description (optional) # You should leave this blank for most of the time description: # Page URL (optional) # You should leave this blank for most of the time url: # Page author (article:author) (optional) # You should leave this blank for most of the time author: # Page images (optional) # You should leave this blank for most of the time image: # Additional HTML meta tags in an array meta: # Meta tags specified in &lt;attribute&gt;=&lt;value&gt; style. # E.g., name=theme-color;content=#123456 =&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#123456&quot;&gt; # URL or path to the website's RSS atom.xml rss: # Page top navigation bar configurationsnavbar: # 导航菜单项 menu: 首页: / 文章归档: /archives 分类: /categories 标签: /tags 个人简介: /about 留言: /message # 链接显示在导航栏的右侧 links: Download on GitHub: icon: fab fa-github url: https://github.com/cccccrz# 页脚配置footer: # Copyright text # HTML code of copyright information in footer copyright: © 版权说明：[本网站所有内容均收集于互联网或自己创作,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;方便于网友与自己学习交流，如有侵权，请&lt;a href=&quot;/message&quot; target=&quot;_blank&quot;&gt;留言&lt;/a&gt;，立即处理]&lt;br /&gt; # 链接显示在页脚部分的右侧 links: Download on GitHub: icon: fab fa-github url: https://github.com/cccccrz # Start time of this website in footer (omitted to be invisible) # NOTE: The value will be passed in the constructor of the ``Date`` # object. Read the documentation on Date() constructor # (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/ Global_Objects/Date/Date) for further information. # Recommended form: yyyy/mm/dd hh:mm:ss or yyyy-mm-ddThh:mm:ss # i.e. 1995/12/17 13:24:00 or 1995-12-17T13:24:00 #website_start_time: '' # ICP licensing information in footer #icp_licensing: # enabled: false # number: '' # url: 'https://beian.miit.gov.cn/'# 文章相关配置article: # Code highlight settings highlight: enabled: true # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # Show copy code button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # 是否显示估计的文章阅读时间 readtime: true # Article licensing block licenses: Creative Commons: icon: fab fa-creative-commons url: https://creativecommons.org/ Attribution: icon: fab fa-creative-commons-by url: https://creativecommons.org/licenses/by/4.0/ Noncommercial: icon: fab fa-creative-commons-nc url: https://creativecommons.org/licenses/by-nc/4.0/# 侧栏配置。# 请注意，侧栏只有在至少有一个widget时才可见sidebar: # Left sidebar configurations left: # 当页面滚动时，侧边栏是否粘在顶部 sticky: true # Right sidebar configurations right: # Whether the sidebar sticks to the top when page scrolls sticky: false# 侧栏widget配置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: # 目录widget, Table of contents widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: toc # Select show index index: false # Showing mode # Available values: # - 'pages_and_posts' (shown in pages and posts like that in the old version) # - 'default' (not shown in pages and posts) show_mode: pages_and_posts # 个人信息widget,Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: profile # Author name author: TTY # Author title author_title: 一个兴趣使然的coder # Author's current location location: 中国,江苏,南京 # URL or path to the avatar image avatar: /img/head.jpg # 是否显示圆形头像图像 avatar_rounded: false # Email address for the Gravatar gravatar: # URL or path for the follow button follow_link: 'https://github.com/cccccrz' # Links to be shown on the bottom of the profile widget social_links: Github: icon: fab fa-github url: https://github.com/cccccrz # Weibo: # icon: fab fa-weibo # url: '' # Email: # icon: fa fa-envelope # url: '' # Next: # icon: fab fa-dribbble # url: '' # RSS: # icon: fas fa-rss # url: has_hitokoto: true show_mode: default # 推荐链接widget,Recommendation links widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: links # Names and URLs of the sites links: Hexo: https://hexo.io show_mode: default # Latest comment widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: latest_comment show_mode: default # 最近提交，Recent posts widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: recent_posts show_mode: default # 类别目录，Categories widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: categories show_mode: default # 档案，Archives widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: archives show_mode: default # 标签，Tags widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: tags show_mode: default# Plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/plugins: # 启用页面启动动画；Enable page startup animations animejs: true # 显示“返回顶部”按钮；Show the &quot;back to top&quot; button back_to_top: true # 百度分析插件设置；Baidu Analytics plugin settings # https://tongji.baidu.com baidu_analytics: # Baidu Analytics tracking ID tracking_id: # BuSuanZi网站/页面访问量计数器；BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: true # CNZZ统计；CNZZ statistics # https://www.umeng.com/web cnzz: # CNZZ tracker id id: # CNZZ website id web_id: # Enable the lightGallery and Justified Gallery plugins gallery: true # Google Analytics plugin settings # https://analytics.google.com google_analytics: # Google Analytics tracking ID tracking_id: # Hotjar user feedback plugin # https://www.hotjar.com/ hotjar: # Hotjar site id site_id: # Enable the KaTeX math typesetting support # https://katex.org/ # WARNING: IT NEEDS MORE MAINTENANCE! # katex: false # Enable the MathJax math typesetting support # https://www.mathjax.org/ mathjax: false # 启用过时的浏览器插件；Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated_browser: false # 在页面加载时，在页面顶部显示进度条；Show a progress bar at top of the page on page loading progressbar: true# NOTE: Deprecated!# Search plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search/search: type: insight# NOTE: Deprecated!# Comment plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/comment: enabled: false type: gitalk # Recommended: gitalk language: zh-CN # Localization language key, en, zh-CN and zh-TW are currently available. owner: '' # (required) GitHub user name repo: '' # (required) GitHub repository name client_id: '' # (required) OAuth application client id client_secret: '' # (required) OAuth application client secret admin: [''] create_issue_manually: true distraction_free_mode: false has_hot_recommended: true # Whether to show Hot Recommended has_latest_comments: true # Whether to show Latest Comments proxy: '' # Solve HTTP 403 error after logged in# Donate plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Donation/donates: enabled: false entries: # Alipay donate button configurations - type: alipay # Qrcode image URL qrcode: '' # WeChat donate button configurations - type: wechat # Qrcode image URL qrcode: '' # Share plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/share: enabled: false type: sharethis # URL to the ShareThis share plugin script install_url: ''# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus-user-guide-cdn-providers/providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: loli # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli # URL prefix of assets from CDN # my_cdn_pre: https://cdn.jsdelivr.net/gh/removeif/removeif-demo@v1.0.8/# NOTE: Deprecated!# NetEase Cloud Music playlist ID in footer (at the bottom of the webpage)side_music_netease_id: ''# NOTE: Deprecated!# (required: plugins.busuanzi: true) only calculate the statistics# from busuanzi without showing it when the value is truebusuanzi_only_count: false# Whether to show the Live2D figurehas_live_2D_switch: false# Whether to activate pjax pluginuse_pjax: true","link":"/2023/04/04/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97-2/"},{"title":"网站搭建日志(1)","text":"Buid My Website! Use 文档 | Hexo 初始化安装环境 安装 Git 安装 Node.js 安装 Hexo 构建网站 1hexo init [folder] 修改默认配置 _config.yml URL 123# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'url: https://cccccrz.github.io/ 发布配置 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: git@github.com:cccccrz/cccccrz.github.io.git branch: develop 网站预览新建文章 1hexo new [layout] &lt;title&gt; 生成页面 1hexo generate 提交草稿 1hexo publish [layout] &lt;filename&gt; 启动本地服务，可以通过localhost:4000访问 1hexo s 部署安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 部署 – 提交至_config.yml 配置的git目录 1hexo deploy","link":"/2023/04/04/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97-1/"},{"title":"QGC通信流程","text":"摘要QGC通信流程 连接建立与Vehicle创建LinkManager 连接管理 MAVLinkProtocol MAVLink协议封装 所有的连接，通过LinkManager 创建管理，通过 MAVLinkProtocol 解析封装消息，收到心跳交给 MultiVehicleManager 管理； MultiVehicleManager 根据情况创建 Vehicle 实例， Vehicle 直接监听全局MAVLink对象信号，获取消息，逐级处理 udplink监听本地端口，读到数据后记录所有目标ip，端口为一个会话，视为建立连接；发送消息时会遍历所有已连接的会话，发送 定时刷新连接（1s）： 自动配置的UDP连接 LinkManager::_addUDPAutoConnectLink AutoConnnect.SettingsGroup.json MAVLink转发 LinkManager::_addMAVLinkForwardingLink App.SettingsGroup.json forwardMavlink 默认禁用 启动时加载连接配置：QGCApplication::_initForNormalAppBoot toolbox()-&gt;linkManager()-&gt;loadLinkConfigurationList()","link":"/2023/07/12/QGC%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B/"},{"title":"qt增加mqtt模块","text":"qt官方提供了封装好的mqtt模块，导入即可使用；结合Qt的跨平台，很好用 emqx 写了一个qmqtt，据说掉线状态有些问题；本人倾向于使用Qt官方写的qtmqtt，且封装更到位 qtmqtt git 上的分支对应不同的qt版本 构建首先克隆仓库，切换至自己的qt版本分支，比如5.12.6 使用qt打开qtmqtt.pro 构建Release版本 构建目录构建目录会生成bin，include，lib，mkspecs include是输出的头文件，引用qtmqtt/src mkspecs是模块定义脚本，默认是指向构建目录 Windows需要安装 perl，自动配置环境变量后，重新构建 Android在windows下开发同样需要安装perl 构建步骤禁用 Make install 和 Build Android APK 部署套件目录：Qt目录/{QtVersion}/{编译器}/ 直接部署：构建目录增加 make install， 或者命令行输入 手动拷贝：由于build/include是根据src索引的，我们在根目录下构建 cd qtmqtt &amp;&amp; qmake &amp;&amp; make 将bin，include，lib部署至qt安装目录，对应编译套件 将modules-inst/qt_lib_mqtt.pri modules-inst/qt_lib_mqtt_private.pri 拷贝至套件目录/mkspecs/modules 将qtmqtt/src内的头文件 拷贝至套件目录/include 导入1QT += core netword mqtt core 和 network 是两个依赖的模块，必须导入 可以打开 qtmqtt/examples 进行测试","link":"/2023/07/14/qt%E5%A2%9E%E5%8A%A0mqtt%E6%A8%A1%E5%9D%97/"},{"title":"自定义mavlink协议","text":"本文介绍如何生成自定义mavlink协议 依赖 Python 3.3+ Python future模块 TkInter (required to use the GUI tool). 环境变量PYTHONPATH必须包含mavlink存储库的目录路径。 如果要创建新的XML定义，还应该安装用于XML验证和格式化的lxml和libxml2。 参考mavlink环境搭建或官方手册搭建环境。 自定义mavlink\\message_definitions\\v1.0 增加自定义 XML，如custom.xml 在all.xml里导入 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;mavlink&gt; ... &lt;!-- custom.xml range of IDs: messages: 18000 - 19000 commands: 18000 - 19000 --&gt; &lt;include&gt;custom.xml&lt;/include&gt; ... &lt;messages/&gt;&lt;/mavlink&gt; 参考枚举定义 123456789101112131415161718192021222324252627&lt;enum name=&quot;MAV_MODE_FLAG&quot; bitmask=&quot;true&quot;&gt; &lt;description&gt;These flags encode the MAV mode.&lt;/description&gt; &lt;entry value=&quot;128&quot; name=&quot;MAV_MODE_FLAG_SAFETY_ARMED&quot;&gt; &lt;description&gt;0b10000000 MAV safety set to armed. Motors are enabled / running / can start. Ready to fly. Additional note: this flag is to be ignore when sent in the command MAV_CMD_DO_SET_MODE and MAV_CMD_COMPONENT_ARM_DISARM shall be used instead. The flag can still be used to report the armed state.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;64&quot; name=&quot;MAV_MODE_FLAG_MANUAL_INPUT_ENABLED&quot;&gt; &lt;description&gt;0b01000000 remote control input is enabled.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;32&quot; name=&quot;MAV_MODE_FLAG_HIL_ENABLED&quot;&gt; &lt;description&gt;0b00100000 hardware in the loop simulation. All motors / actuators are blocked, but internal software is full operational.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;16&quot; name=&quot;MAV_MODE_FLAG_STABILIZE_ENABLED&quot;&gt; &lt;description&gt;0b00010000 system stabilizes electronically its attitude (and optionally position). It needs however further control inputs to move around.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;8&quot; name=&quot;MAV_MODE_FLAG_GUIDED_ENABLED&quot;&gt; &lt;description&gt;0b00001000 guided mode enabled, system flies waypoints / mission items.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;4&quot; name=&quot;MAV_MODE_FLAG_AUTO_ENABLED&quot;&gt; &lt;description&gt;0b00000100 autonomous mode enabled, system finds its own goal positions. Guided flag can be set or not, depends on the actual implementation.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;2&quot; name=&quot;MAV_MODE_FLAG_TEST_ENABLED&quot;&gt; &lt;description&gt;0b00000010 system has a test mode enabled. This flag is intended for temporary system tests and should not be used for stable implementations.&lt;/description&gt; &lt;/entry&gt; &lt;entry value=&quot;1&quot; name=&quot;MAV_MODE_FLAG_CUSTOM_MODE_ENABLED&quot;&gt; &lt;description&gt;0b00000001 Reserved for future use.&lt;/description&gt; &lt;/entry&gt;&lt;/enum&gt; 参考心跳的Message定义 123456789&lt;message id=&quot;0&quot; name=&quot;HEARTBEAT&quot;&gt; &lt;description&gt;The heartbeat message shows that a system or component is present and responding. The type and autopilot fields (along with the message component id), allow the receiving system to treat further messages from this system appropriately (e.g. by laying out the user interface based on the autopilot). This microservice is documented at https://mavlink.io/en/services/heartbeat.html&lt;/description&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;type&quot; enum=&quot;MAV_TYPE&quot;&gt;Vehicle or component type. For a flight controller component the vehicle type (quadrotor, helicopter, etc.). For other components the component type (e.g. camera, gimbal, etc.). This should be used in preference to component id for identifying the component type.&lt;/field&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;autopilot&quot; enum=&quot;MAV_AUTOPILOT&quot;&gt;Autopilot type / class. Use MAV_AUTOPILOT_INVALID for components that are not flight controllers.&lt;/field&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;base_mode&quot; enum=&quot;MAV_MODE_FLAG&quot; display=&quot;bitmask&quot;&gt;System mode bitmap.&lt;/field&gt; &lt;field type=&quot;uint32_t&quot; name=&quot;custom_mode&quot;&gt;A bitfield for use for autopilot-specific flags&lt;/field&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;system_status&quot; enum=&quot;MAV_STATE&quot;&gt;System status flag.&lt;/field&gt; &lt;field type=&quot;uint8_t_mavlink_version&quot; name=&quot;mavlink_version&quot;&gt;MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version&lt;/field&gt;&lt;/message&gt; 开始自定义协议custom.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot;?&gt;&lt;mavlink&gt; &lt;version&gt;3&lt;/version&gt; &lt;!-- custom message 18xxx --&gt; &lt;message id=&quot;18001&quot; name=&quot;CUSTOM_DEFINE_1&quot;&gt; &lt;description&gt;custom description 1&lt;/description&gt; &lt;field type=&quot;uint8_t[10]&quot; name=&quot;targetId&quot;&gt;description1&lt;/field&gt; &lt;field type=&quot;uint8_t[10]&quot; name=&quot;targetType&quot;&gt;description2&lt;/field&gt; &lt;field type=&quot;uint16_t[10]&quot; name=&quot;xMin&quot;&gt; description3&lt;/field&gt; &lt;field type=&quot;uint16_t[10]&quot; name=&quot;yMin&quot;&gt; description4&lt;/field&gt; &lt;field type=&quot;uint16_t[10]&quot; name=&quot;xMax&quot;&gt; description5&lt;/field&gt; &lt;field type=&quot;uint16_t[10]&quot; name=&quot;yMax&quot;&gt; description6&lt;/field&gt; &lt;/message&gt; &lt;message id=&quot;18002&quot; name=&quot;CUSTOM_DEFINE_2&quot;&gt; &lt;description&gt;custom description 2&lt;/description&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;cmdType&quot;&gt;start from 1,0 is null&lt;/field&gt; &lt;field type=&quot;uint8_t&quot; name=&quot;targetId&quot;&gt;start from 1,0 is to custom rectangle area&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;xMin&quot;&gt; target pixel left top x&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;yMin&quot;&gt; target pixel left top y&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;xMax&quot;&gt; target pixel right bottom x&lt;/field&gt; &lt;field type=&quot;uint16_t&quot; name=&quot;yMax&quot;&gt; target pixel right bottom y&lt;/field&gt; &lt;/message&gt; ... &lt;/messages&gt;&lt;/mavlink&gt; 生成1python3 -m mavgenerate XML 选择qll.xml 全部生成 Out 输出目录自定 Language，Protocol 自选，这里选c++11，2.0 点击Generate生成头文件 自行导入并使用 参考文章:Generate MAVLink Libraries · MAVLink Developer Guide","link":"/2023/07/14/%E8%87%AA%E5%AE%9A%E4%B9%89mavlink%E5%8D%8F%E8%AE%AE/"},{"title":"git配置公钥","text":"记录git配置 生成本机公钥12cd ~/.sshssh-keygen -t rsa -C &quot;邮箱地址&quot; github 创建 SSH keySettings -&gt; SSH and GPG keys -&gt; New SSH key -&gt; Add SSH key Add new SSH keys (github.com)","link":"/2023/07/14/git%E9%85%8D%E7%BD%AE%E5%85%AC%E9%92%A5/"},{"title":"qml学习-2-基本元素","text":"Basic Elements 元素可以被分为可视化元素与⾮可视化元素。⼀个可视化元素（例如矩形框 Rectangle）有着⼏何形状并且可以在屏幕上显⽰。⼀个⾮可视化元素（例如 计时器Timer）提供了常⽤的功能，通常⽤于操作可视化元素。 现在我们将专注于⼏个基础的可视化元素，例如Item（基础元素对象）， Rectangle（矩形框），Text（⽂本），Image（图像）和MouseArea（⿏标 区域）。 基础元素对象（Item Element）Item（基础元素对象）是所有可视化元素的基础对象，所有其它的可视化元素都继承⾃Item。它⾃⾝不会有任何绘制操作，但是定义了所有可视化元素 共有的属性： Group（分组） Properties（属性） Geometry（几何属性） x,y（坐标）定义了元素左上⾓的位置，width，height（⻓ 和宽）定义元素的显⽰范围，z（堆叠次序）定义元素之间 的重叠顺序。 Layout handing（布局操作） anchors（锚点），包括左（left），右（right），上 （top），下（bottom），⽔平与垂直居中（vertical center，horizontal center），与margins（间距）⼀起定义了元素与其它元素之间的位置关系。 Key handing（按键操作） 附加属性key（按键）和keyNavigation（按键定位）属性来控制按键操作，处理输⼊焦点（focus）可⽤操作。 Transformation（转换） 缩放（scale）和rotate（旋转）转换，通⽤的x,y,z属性列表转换（transform），旋转基点设置 （transformOrigin）。 Visual（可视化） 不透明度（opacity）控制透明度，visible（是否可⻅）控制元素是否显⽰，clip（裁剪）⽤来限制元素边界的绘制， smooth（平滑）⽤来提⾼渲染质量。 State definition（状态定义） states（状态列表属性）提供了元素当前所⽀持的状态列 表，当前属性的改变也可以使⽤transitions（转变）属性列 表来定义状态转变动画。 Item（基本元素对象）通常被⽤来作为其它元素的容器使⽤，类似HTML语 ⾔中的div元素（div element）。 Rectangle（矩形元素）Rectangle（矩形框）是基本元素对象的⼀个扩展，增加了⼀个颜⾊来填充它。它还⽀持边界的定义，使⽤border.color（边界颜⾊）， border.width（边界宽度）来⾃定义边界。你可以使⽤radius（半径）属性来 创建⼀个圆⾓矩形。 12345678Rectangle { id: rect1 x: 112; y: 12 width: 76; height: 96 border.color: &quot;lightsteelblue&quot; border.width: 4 radius: 8 } 注意颜⾊的命名是来⾃SVG颜⾊的名称（查看CSS Color Module Level 3)可以获取更多的颜⾊名称）。你也可以使⽤其它的⽅法来 指定颜⾊，⽐如RGB字符串（’#FF4444’），或者⼀个颜⾊名字（例 如’white’）。 此外，填充的颜⾊与矩形的边框也⽀持⾃定义的渐变⾊。 12345678910Rectangle { id: rect1 x: 12; y: 12 width: 176; height: 96 gradient: Gradient { GradientStop { position: 0.0; color: &quot;lightsteelblue&quot; } GradientStop { position: 1.0; color: &quot;slategray&quot; } } border.color: &quot;slategray&quot; } ⼀个渐变⾊是由⼀系列的梯度值定义的。每⼀个值定义了⼀个位置与颜⾊。 位置标记了y轴上的位置（0 = 顶，1 = 底）。GradientStop（倾斜点）的颜⾊标记了颜⾊的位置。 注意 ⼀个矩形框如果没有width/height（宽度与⾼度）将不可⻅。如果你有⼏个 相互关联width/height（宽度与⾼度）的矩形框，在你组合逻辑中出了错后可能就会发⽣矩形框不可⻅，请注意这⼀点。 注意 这个函数⽆法创建⼀个梯形，最好使⽤⼀个已有的图像来创建梯形。有⼀种可能是在旋转梯形时，旋转的矩形⼏何结构不会发⽣改变，但是这会导致⼏何元素相同的可⻅区域的混淆。从作者的观点来看类似的情况下最好使⽤设计好的梯形图形来完成绘制。 Text（文本元素）显⽰⽂本你需要使⽤Text元素（Text Element）。它最值得注意的属性时字符串类型的text属性。这个元素会使⽤给出的text（⽂本）与font（字体）来计算初始化的宽度与⾼度。可以使⽤字体属性组来（font property group）来改变当前的字体，例如font.family，font.pixelSize，等等。改变⽂本的颜⾊值只需要改变颜⾊属性就可以了。 123456Text { text: &quot;The quick brown fox&quot; color: &quot;#303030&quot; font.family: &quot;Ubuntu&quot; font.pixelSize: 28 } ⽂本可以使⽤horizontalAlignment与verticalAlignment属性来设置它的对⻬效果。为了提⾼⽂本的渲染效果，你可以使⽤style和styleColor属性来配置⽂字的外框效果，浮雕效果或者凹陷效果。对于过⻓的⽂本，你可能需要使⽤省略号来表⽰，例如A very ... long text，你可以使⽤elide属性来完成这个操 作。elide属性允许你设置⽂本左边，右边或者中间的省略位置。如果你不 想’….’省略号出现，并且希望使⽤⽂字换⾏的⽅式显⽰所有的⽂本，你可以使⽤wrapMode属性（这个属性只在明确设置了宽度后才⽣效）： 1234567891011121314151617Text { width: 40; height: 120 text: 'A very long text' // '...' shall appear in the middle elide: Text.ElideMiddle // red sunken text styling style: Text.Sunken styleColor: '#FF4444' // align text to the top verticalAlignment: Text.AlignTop // only sensible when no elide mode // wrapMode: Text.WordWrap } ⼀个text元素（text element）只显⽰的⽂本，它不会渲染任何背景修饰。除了显⽰的⽂本，text元素背景是透明的。为⼀个⽂本元素提供背景是你⾃⼰需要考虑的问题。 注意 知道⼀个⽂本元素（Text Element）的初始宽度与⾼度是依赖于⽂本字符串和设置的字体这⼀点很重要。⼀个没有设置宽度或者⽂本的⽂本元素（Text Element）将不可⻅，默认的初始宽度是0。 注意 通常你想要对⽂本元素布局时，你需要区分⽂本在⽂本元素内部的边界对⻬和由元素边界⾃动对⻬。前⼀种情况你需要使⽤horizontalAlignment和 verticalAlignment属性来完成，后⼀种情况你需要操作元素的⼏何形状或者使⽤anchors（锚定）来完成。 Image（图像元素）⼀个图像元素（Image Element）能够显⽰不同格式的图像（例如 PNG,JPG,GIF,BMP）。想要知道更加详细的图像格式⽀持信息，可以查看 Qt的相关⽂档。source属性（source property）提供了图像⽂件的链接信息，fillMode（⽂件模式）属性能够控制元素对象的⼤⼩调整⾏为。 12345678910111213141516Image { x: 12; y: 12 // width: 48 // height: 118 source: &quot;assets/rocket.png&quot; }Image { x: 112; y: 12 width: 48 // 减少了高 height: 118/2 source: &quot;assets/rocket.png&quot; fillMode: Image.PreserveAspectCrop // 允许裁剪 clip: true } // 此图只显示部分 注意 ⼀个URL可以是使⽤’/‘语法的本地路径（”./images/home.png”）或者⼀个网络链接（”http://example.org/home.png&quot;）。 注意 图像元素（Image element）使⽤PreserveAspectCrop可以避免裁剪图像 数据被渲染到图像边界外。默认情况下裁剪是被禁⽤的（clip:false）。你需 要打开裁剪（clip:true）来约束边界矩形的绘制。这对任何可视化元素都是有效的。 建议使⽤QQmlImageProvider你可以通过C++代码来创建⾃⼰的图像提供器，这允许你动态创建图像并且使⽤线程加载。 MouseArea（⿏标区域元素）为了与不同的元素交互，你通常需要使⽤MouseArea（⿏标区域）元素。这是⼀个矩形的⾮可视化元素对象，你可以通过它来捕捉⿏标事件。当⽤户与可视化端⼝交互时，mouseArea通常被⽤来与可视化元素对象⼀起执⾏命令。 1234567891011121314151617181920Rectangle { id: rect1 x: 12; y: 12 width: 76; height: 96 color: &quot;lightsteelblue&quot; MouseArea { id: area width: parent.width height: parent.height onClicked: rect2.visible = !rect2.visible } }Rectangle { id: rect2 x: 112; y: 12 width: 76; height: 96 border.color: &quot;lightsteelblue&quot; border.width: 4 radius: 8 } 注意 这是QtQuick中⾮常重要的概念，输⼊处理与可视化显⽰分开。这样你的交互区域可以⽐你显⽰的区域⼤很多。","link":"/2023/07/14/qml%E5%AD%A6%E4%B9%A0-2-%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0/"},{"title":"qml学习-1","text":"初识js，qml QML是⼀种描述⽤户界⾯的声明式语⾔。它将⽤户界⾯分解成⼀些更⼩的元素，这些元素能够结合成⼀个组件。QML语⾔描述了⽤户界⾯元素的形状和⾏为。⽤户界⾯能够使⽤JavaScript来提供修饰，或者增加更加复杂的逻辑。从这个⾓度来看它遵循HTML-JavaScript模式，但QML是被设计⽤来描述⽤户界⾯的，⽽不是⽂本⽂档。 从QML元素的层次结构来理解是最简单的学习⽅式。⼦元素从⽗元素上继承了坐标系统，它的x,y坐标总是相对应于它的⽗元素坐标系统。 语法（QML Syntax）一个小例子 123456789101112131415161718192021222324252627282930313233343536// rectangle.qml import QtQuick 2.0 // 根元素Rectangle { // 命名为 root id: root // 属性 &lt;name&gt;: &lt;value&gt; width: 120; height: 240 // color property color: &quot;#D8D8D8&quot; // 子元素 Image { id: rocket // 引用父元素 x: (parent.width - width)/2; y: 40 source: 'assets/rocket.png' } // Another child of root Text { // 无命名 // 用id引用元素 y: rocket.y + rocket.height + 20 // 引用root元素 width: root.width horizontalAlignment: Text.AlignHCenter text: 'Rocket' } } import声明导⼊了⼀个指定的模块版本。⼀般来说会导⼊QtQuick2.0来作为初始元素的引⽤。 使⽤//可以单⾏注释，使⽤/**/可以多⾏注释，就像C/C++和JavaScript⼀样。 每⼀个QML⽂件都需要⼀个根元素，就像HTML⼀样。 ⼀个元素使⽤它的类型声明，然后使⽤{}进⾏包含。 元素拥有属性，他们按照name:value的格式来赋值。 任何在QML⽂档中的元素都可以使⽤它们的id进⾏访问（id是⼀个任意的标识符）。 元素可以嵌套，这意味着⼀个⽗元素可以拥有多个⼦元素。⼦元素可以通过访问parent关键字来访问它们的⽗元素。 建议 你会经常使⽤id或者关键字parent来访问你的⽗对象。有⼀个⽐较好的⽅法 是命名你的根元素对象id为root（id:root），这样就不⽤去思考你的QML⽂档中的根元素应该⽤什么⽅式命名了。 提示 可以在命令行使用QtQuick运行环境来运行qml 1$QTDIR/bin/qmlscene rectangle.qml 属性（property）元素使⽤他们的元素类型名进⾏声明，使⽤它们的属性或者创建⾃定义属性来定义。⼀个属性对应⼀个值，例如 width:100，text: 'Greeting', color: '#FF0000'。⼀个属性有⼀个类型定义并且需要⼀个初始值。 1234567891011121314151617181920212223242526272829303132333435Text { // (1) identifier id: thisLabel // (2) set x- and y-position x: 24; y: 16 // (3) 属性绑定: bind height to 2 * width height: 2 * width // (4) 自定义属性 property int times: 24 // (5) 属性别名 property alias anotherTimes: thisLabel.times // (6) 属性绑定: set text appended by value text: &quot;Greetings &quot; + times // (7) font是一个分组属性 font.family: &quot;Ubuntu&quot; font.pixelSize: 24 // (8) KeyNavigation是一个附加属性 KeyNavigation.tab: otherLabel // (9) 属性改变触发的槽 onHeightChanged: console.log('height:', height) // 接收键盘事件需要焦点 focus: true // 属性绑定:根据焦点值改变颜色 color: focus?&quot;red&quot;:&quot;black&quot; } id是⼀个⾮常特殊的属性值，它在⼀个QML⽂件中被⽤来引⽤元素。id 不是⼀个字符串，⽽是⼀个标识符和QML语法的⼀部分。⼀个id在⼀个 QML⽂档中是唯⼀的，并且不能被设置为其它值，也⽆法被查询（它的⾏为更像C++世界⾥的指针）。 ⼀个属性能够设置⼀个值，这个值依赖于它的类型。如果没有对⼀个属性赋值，那么它将会被初始化为⼀个默认值。你可以查看特定的元素的⽂档来获得这些初始值的信息。 ⼀个属性能够依赖⼀个或多个其它的属性，这种操作称作属性绑定。当它依赖的属性改变时，它的值也会更新。这就像订了⼀个协议，在这个例⼦中height始终是width的两倍。 添加⾃⼰定义的属性需要使⽤property修饰符，然后跟上类型，名字和可 选择的初始化值（property : ）。如果没有初始值将会给定⼀个系统初始 值作为初始值。注意如果属性名与已定义的默认属性名不重复，使⽤default关键字你可以将⼀个属性定义为默认属性。这在你添加⼦元素时⽤得着，如果他们是可视化的元素，⼦元素会⾃动的添加默认属性的⼦类型链表（children property list）。 另⼀个重要的声明属性的⽅法是使⽤alias关键字（property alias : ）。 alias关键字允许我们转发⼀个属性或者转发⼀个属性对象⾃⾝到另⼀个作⽤域。我们将在后⾯定义组件导出内部属性或者引⽤根级元素id会使⽤到这个技术。⼀个属性别名不需要类型，它使⽤引⽤的属性类型或者对象类型。 text属性依赖于⾃定义的timers（int整型数据类型）属性。int整型数据会⾃动的转换为string字符串类型数据。这样的表达⽅式本⾝也是另⼀种属性绑定的例⼦，⽂本结果会在times属性每次改变时刷新。 ⼀些属性是按组分配的属性。当⼀个属性需要结构化并且相关的属性需要联系在⼀起时，我们可以这样使⽤它。另⼀个组属性的编码⽅式是 1font { family: &quot;UBuntu&quot;; pixelSize: 24 } ⼀些属性是元素⾃⾝的附加属性。这样做是为了全局的相关元素在应⽤程序中只出现⼀次（例如键盘输⼊）。 对于每个元素你都可以提供⼀个信号操作。这个操作在属性值改变时被调⽤。例如这⾥我们完成了当height（⾼度）改变时会使⽤控制台输出 ⼀个信息 警告 ⼀个元素id应该只在当前⽂档中被引⽤。QML提供了动态作⽤域的机制，后加载的⽂档会覆盖之前加载⽂档的元素id号，这样就可以引⽤已加载并且没有被覆盖的元素id，这有点类似创建全局变量。但不幸的是这样的代码阅读性很差。目前还没有办法解决这个问题，所以你使⽤这个机制的时候最好仔细⼀些甚⾄不要使⽤这种机制。如果你想向⽂档外提供元素的调⽤，你可以在根元素上使⽤属性导出的⽅式来提供。 脚本（Scripting）12345678910111213141516171819202122Text { id: label x: 24; y: 24 // custom counter property for space presses property int spacePresses: 0 text: &quot;Space pressed: &quot; + spacePresses + &quot; times&quot; // (1) handler for text changes onTextChanged: console.log(&quot;text changed to:&quot;, text) // need focus to receive key events focus: true // (2) handler with some JS Keys.onSpacePressed: { increment() } // clear the text on escape Keys.onEscapePressed: { label.text = '' } // (3) a JS function function increment() { spacePresses = spacePresses + 1 } } ⽂本改变操作onTextChanged会将每次空格键按下导致的⽂本改变输出 到控制台。 当⽂本元素接收到空格键操作（⽤户在键盘上点击空格键），会调⽤ JavaScript函数increment()。 定义⼀个JavaScript函数使⽤这种格式function (){….}，在这个例⼦中是 增加spacePressed的计数。每次spacePressed的增加都会导致它绑定的 属性更新。 注意 QML的：（属性绑定）与JavaScript的=（赋值）是不同的。绑定是⼀个协议，并且存在于整个⽣命周期。然⽽JavaScript赋值（=）只会产⽣⼀次效果。当⼀个新的绑定⽣效或者使⽤JavaScript赋值给属性时，绑定的⽣命周期就会结束。例如⼀个按键的操作设置⽂本属性为⼀个空的字符串将会销毁我们的增值显⽰：Keys.onEscapePressed: { label.text = '' }在点击取消（ESC）后，再次点击空格键（space-bar）将不会更新我们的显⽰，之前的text属性绑定（text: &quot;Space pressed:&quot; + spacePresses + &quot;times&quot;)被销毁。 当你对改变属性的策略有冲突时（⽂本的改变基于⼀个增值的绑定并且可以被JavaScript赋值清零），类似于这个例⼦，你最好不要使⽤绑定属性。你需要使⽤赋值的⽅式来改变属性，属性绑定会在赋值操作后被销毁（销毁协议！）","link":"/2023/05/10/qml%E5%AD%A6%E4%B9%A0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"qt","slug":"qt","link":"/tags/qt/"},{"name":"QGC","slug":"QGC","link":"/tags/QGC/"},{"name":"QML","slug":"QML","link":"/tags/QML/"},{"name":"mavlink","slug":"mavlink","link":"/tags/mavlink/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"mqtt","slug":"mqtt","link":"/tags/mqtt/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"轮子","slug":"轮子","link":"/categories/%E8%BD%AE%E5%AD%90/"},{"name":"qt","slug":"qt","link":"/categories/qt/"},{"name":"查漏补缺","slug":"c/查漏补缺","link":"/categories/c/%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"},{"name":"QGC","slug":"qt/QGC","link":"/categories/qt/QGC/"},{"name":"QML","slug":"qt/QML","link":"/categories/qt/QML/"},{"name":"mavlink","slug":"mavlink","link":"/categories/mavlink/"},{"name":"windows","slug":"windows","link":"/categories/windows/"},{"name":"学习日志","slug":"学习日志","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"},{"name":"数据结构","slug":"学习日志/数据结构","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"学习日志/算法","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E7%AE%97%E6%B3%95/"},{"name":"网站搭建","slug":"学习日志/网站搭建","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"git","slug":"git","link":"/categories/git/"}],"pages":[{"title":"","text":"个人简介 💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息： 尤文图斯死忠粉；二刺猿；程序猿；主机游戏爱好者 博客信息 网站采用的amazingremake主题~ 本站推荐索引 博客主题相关 博客源码分享 amazing Amazing Remake 从 GitHub 迁移到 jsDelivr 技术知识点 isocpp/CppCoreGuidelines：C++ Core Guides是一套关于C++编码的行之有效的指南、规则和最佳实践 Qicosmos/Cosmos： C++11基础库 krenx1983/think: 纯C语言跨平台开发框架","link":"/about/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标： 网站名称：ONE PIECE 网站地址：https://cccccrz.github.io/ 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}]}